{
  "version": 3,
  "sources": ["../src/vec2.js", "../src/BinarySearch.js", "../src/TouchGestures.js", "../src/mergeObjects.js", "../src/Hints.js", "../src/Legends.js", "../src/Chart.js", "../src/Dataset.js"],
  "sourcesContent": ["function clamp(min, max, x) {\r\n    return Math.max(min, Math.min(x, max))\r\n}\r\n\r\nfunction isZero(x, eps = 0.001) {\r\n    return Math.abs(x) < eps\r\n}\r\n\r\nfunction vec2(x = 0, y = 0) {\r\n    return [ x, y ]\r\n}\r\n\r\nfunction vec2clone(p) {\r\n    return vec2(p[0], p[1])\r\n}\r\n\r\nfunction vec2set(r, x, y) {\r\n    r[0] = x\r\n    r[1] = y\r\n    return r\r\n}\r\n\r\nfunction vec2copy(r, p) {\r\n    r[0] = p[0]\r\n    r[1] = p[1]\r\n    return r\r\n}\r\n\r\nfunction vec2add(r, p1, p2) {\r\n    r[0] = p1[0] + p2[0]\r\n    r[1] = p1[1] + p2[1]\r\n    return r\r\n}\r\n\r\nfunction vec2sub(r, p1, p2) {\r\n    r[0] = p1[0] - p2[0]\r\n    r[1] = p1[1] - p2[1]\r\n    return r\r\n}\r\n\r\nfunction vec2mul(r, p1, p2) {\r\n    r[0] = p1[0] * p2[0]\r\n    r[1] = p1[1] * p2[1]\r\n    return r\r\n}\r\n\r\nfunction vec2div(r, p1, p2) {\r\n    r[0] = p1[0] / p2[0]\r\n    r[1] = p1[1] / p2[1]\r\n    return r\r\n}\r\n\r\nfunction vec2lerp(r, p1, p2, s) {\r\n    r[0] = p1[0] + s[0] * (p2[0] - p1[0])\r\n    r[1] = p1[1] + s[1] * (p2[1] - p1[1])\r\n    return r\r\n}\r\n\r\nfunction vec2neglerp(r, p1, p2, s) {\r\n    r[0] = p1[0] - s[0] * (p2[0] - p1[0])\r\n    r[1] = p1[1] - s[1] * (p2[1] - p1[1])\r\n    return r\r\n}\r\n\r\nfunction vec2clamp(r, min, max, p) {\r\n    r[0] = clamp(min, max, p[0])\r\n    r[1] = clamp(min, max, p[1])\r\n    return r\r\n}\r\n\r\nfunction vec2muladd(r, p, s, t) {\r\n    r[0] = p[0] * s[0] + t[0]\r\n    r[1] = p[1] * s[1] + t[1]\r\n    return r\r\n}\r\n\r\nfunction vec2subdiv(r, p, s, t) {\r\n    r[0] = (p[0] - t[0]) / s[0]\r\n    r[1] = (p[1] - t[1]) / s[1]\r\n    return r\r\n}\r\n\r\nexport {\r\n\r\n    clamp,\r\n    isZero,\r\n    vec2,\r\n    vec2clone,\r\n    vec2set,\r\n    vec2copy,\r\n    vec2add,\r\n    vec2sub,\r\n    vec2mul,\r\n    vec2div,\r\n    vec2lerp,\r\n    vec2neglerp,\r\n    vec2clamp,\r\n    vec2muladd,\r\n    vec2subdiv\r\n}", "const findLess = (getter, low, high, key) => {\n    let result = -1\n    while (low <= high) {\n        let mid = low + Math.floor((high - low + 1) / 2)\n        let midVal = getter(mid)\n        if (midVal < key) {\n            result = mid\n            low = mid + 1\n        } else if (midVal > key) {\n            high = mid - 1\n        } else if (midVal === key) {\n            high = mid - 1\n        }\n    }\n    return result\n}\n\nexport {\n\n    findLess\n}\n", "const dropEvent = evt => {\r\n\r\n    evt.preventDefault()\r\n    evt.stopPropagation()\r\n\r\n    console.log('drop', evt.type)\r\n}\r\n\r\nconst EVT_NAME_POINTERDOWN = 'sim:pointerdown'\r\nconst EVT_NAME_POINTERMOVE = 'sim:pointermove'\r\nconst EVT_NAME_POINTERUP = 'sim:pointerup'\r\nconst EVT_NAME_POINTERZOOM = 'sim:pointerzoom'\r\n\r\nconst defaultOptions = {\r\n    listenerElement: null,\r\n    invertMouseWheel: false,\r\n    mouseWheelStep: 0.1\r\n}\r\n\r\nclass TouchGestures {\r\n\r\n    constructor(element, options = {}) {\r\n\r\n        const opts = { ...defaultOptions, ...options }\r\n\r\n        this.element = element\r\n        this.listenerElement = opts.listenerElement !== null ? opts.listenerElement : element\r\n\r\n        const fireEvent = (name, detail) => {\r\n            return this.element.dispatchEvent(new CustomEvent(name, { detail })) // TODO it does not returns false when evt.preventDefault() is called\r\n        }\r\n\r\n        const pointerdown = (originalEvent, x, y) => fireEvent(EVT_NAME_POINTERDOWN, { originalEvent, clientX: x, clientY: y })\r\n        const pointerup = (originalEvent, x, y) => fireEvent(EVT_NAME_POINTERUP, { originalEvent, clientX: x, clientY: y })\r\n        const pointerzoom = (originalEvent, x, y, deltaScale) => fireEvent(EVT_NAME_POINTERZOOM, { originalEvent, clientX: x, clientY: y, deltaScale })\r\n        const pointermove = (originalEvent, x, y, dx, dy) => fireEvent(EVT_NAME_POINTERMOVE, { originalEvent, clientX: x, clientY: y, movementX: dx, movementY: dy })\r\n\r\n        let touchId = null\r\n        let secondTouchId = null\r\n        const touchPoint = { x: 0, y: 0 }\r\n        const secondTouchPoint = { x: 0, y: 0 }\r\n        const wheelDirection = opts.invertMouseWheel ? -1 : 1\r\n        const wheelStep = opts.mouseWheelStep\r\n\r\n        this.listeners = {\r\n\r\n            touchstart: evt => {\r\n                let result\r\n                const clientRect = evt.target.getBoundingClientRect()\r\n                if (touchId !== null) {\r\n                    const touch = evt.changedTouches[0]\r\n                    if (touch.identifier !== touchId) {\r\n                        secondTouchId = touch.identifier\r\n                        secondTouchPoint.x = touch.clientX - clientRect.left\r\n                        secondTouchPoint.y = touch.clientY - clientRect.top\r\n                        let res\r\n                        res = pointerup(evt, touchPoint.x, touchPoint.y)\r\n                        if (res === false) {\r\n                            result = false\r\n                        }\r\n                        res = pointerdown(\r\n                            evt,\r\n                            touchPoint.x + (secondTouchPoint.x - touchPoint.x) / 2,\r\n                            touchPoint.y + (secondTouchPoint.y - touchPoint.y) / 2\r\n                        )\r\n                        if (res === false) {\r\n                            result = false\r\n                        }\r\n                    }\r\n                } else {\r\n                    const touch = evt.changedTouches[0]\r\n                    touchId = touch.identifier\r\n                    touchPoint.x = touch.clientX - clientRect.left\r\n                    touchPoint.y = touch.clientY - clientRect.top\r\n                    let res\r\n                    res = pointerdown(evt, touchPoint.x, touchPoint.y)\r\n                    if (res === false) {\r\n                        result = false\r\n                    }\r\n                }\r\n                if (result === false) {\r\n                    evt.stopPropagation()\r\n                    evt.preventDefault()\r\n                }\r\n                return result\r\n            },\r\n\r\n            touchend: evt => {\r\n                let result\r\n                let touches = Array.from(evt.changedTouches)\r\n                if (touchId !== null && secondTouchId !== null) {\r\n                    const touch = touches.find(touch => touchId === touch.identifier)\r\n                    const secondTouch = touches.find(touch => secondTouchId === touch.identifier)\r\n                    let res\r\n                    res = pointerup(\r\n                        evt,\r\n                        touchPoint.x + (secondTouchPoint.x - touchPoint.x) / 2,\r\n                        touchPoint.y + (secondTouchPoint.y - touchPoint.y) / 2\r\n                    )\r\n                    if (res === false) {\r\n                        result = false\r\n                    }\r\n                    if (touch && secondTouch) {\r\n                        touchId = null\r\n                        secondTouchId = null\r\n                    } else if (touch && !secondTouch) {\r\n                        touchId = secondTouchId\r\n                        touchPoint.x = secondTouchPoint.x\r\n                        touchPoint.y = secondTouchPoint.y\r\n                        secondTouchId = null\r\n                    } else if (!touch && secondTouch) {\r\n                        secondTouchId = null\r\n                    }\r\n                    if (touchId !== null) {\r\n                        res = pointerdown(evt, touchPoint.x, touchPoint.y)\r\n                        if (res === false) {\r\n                            result = false\r\n                        }\r\n                    }\r\n                } else if (touchId !== null) {\r\n                    const touch = touches.find(touch => touchId === touch.identifier)\r\n                    if (touch) {\r\n                        touchId = null\r\n                        let res\r\n                        res = pointerup(evt, touchPoint.x, touchPoint.y)\r\n                        if (res === false) {\r\n                            result = false\r\n                        }\r\n                    }\r\n                }\r\n                if (result === false) {\r\n                    evt.stopPropagation()\r\n                    evt.preventDefault()\r\n                }\r\n                return result\r\n            },\r\n\r\n            touchmove: evt => {\r\n                let result\r\n                const clientRect = evt.target.getBoundingClientRect()\r\n                if (touchId !== null && secondTouchId !== null) {\r\n                    const touchNewPoint = { x: touchPoint.x, y: touchPoint.y }\r\n                    const secondTouchNewPoint = { x: secondTouchPoint.x, y: secondTouchPoint.y }\r\n                    const touch = Array.from(evt.changedTouches).find(touch => touchId === touch.identifier)\r\n                    const secondTouch = Array.from(evt.changedTouches).find(touch => secondTouchId === touch.identifier)\r\n                    if (touch) {\r\n                        touchNewPoint.x = touch.clientX - clientRect.left\r\n                        touchNewPoint.y = touch.clientY - clientRect.top\r\n                    }\r\n                    if (secondTouch) {\r\n                        secondTouchNewPoint.x = secondTouch.clientX - clientRect.left\r\n                        secondTouchNewPoint.y = secondTouch.clientY - clientRect.top\r\n                    }\r\n                    const dx = secondTouchPoint.x - touchPoint.x\r\n                    const dy = secondTouchPoint.y - touchPoint.y\r\n                    const dxNew = secondTouchNewPoint.x - touchNewPoint.x\r\n                    const dyNew = secondTouchNewPoint.y - touchNewPoint.y\r\n                    const previousLength = Math.hypot(dx, dy)\r\n                    const length = Math.hypot(dxNew, dyNew)\r\n                    const deltaScale = (1 - (previousLength / length))\r\n                    const point = {\r\n                        x: touchPoint.x + dx / 2,\r\n                        y: touchPoint.y + dy / 2\r\n                    }\r\n                    const pointNew = {\r\n                        x: touchNewPoint.x + dxNew / 2,\r\n                        y: touchNewPoint.y + dyNew / 2\r\n                    }\r\n                    let res\r\n                    res = pointermove(\r\n                        evt,\r\n                        pointNew.x,\r\n                        pointNew.y,\r\n                        pointNew.x - point.x,\r\n                        pointNew.y - point.y\r\n                    )\r\n                    if (res === false) {\r\n                        result = false\r\n                    }\r\n                    res = pointerup(evt, pointNew.x, pointNew.y)\r\n                    if (res === false) {\r\n                        result = false\r\n                    }\r\n                    res = pointerzoom(evt, pointNew.x, pointNew.y, deltaScale)\r\n                    if (res === false) {\r\n                        result = false\r\n                    }\r\n                    res = pointerdown(evt, pointNew.x, pointNew.y)\r\n                    if (res === false) {\r\n                        result = false\r\n                    }\r\n                    touchPoint.x = touchNewPoint.x\r\n                    touchPoint.y = touchNewPoint.y\r\n                    secondTouchPoint.x = secondTouchNewPoint.x\r\n                    secondTouchPoint.y = secondTouchNewPoint.y\r\n                } else if (touchId !== null) {\r\n                    const touchNewPoint = { x: touchPoint.x, y: touchPoint.y }\r\n                    const touch = Array.from(evt.changedTouches)\r\n                        .find(touch => touchId === touch.identifier)\r\n                    if (!touch) {\r\n                        return\r\n                    }\r\n                    touchNewPoint.x = touch.clientX - clientRect.left\r\n                    touchNewPoint.y = touch.clientY - clientRect.top\r\n                    let res\r\n                    res = pointermove(\r\n                        evt,\r\n                        touchNewPoint.x,\r\n                        touchNewPoint.y,\r\n                        touchNewPoint.x - touchPoint.x,\r\n                        touchNewPoint.y - touchPoint.y\r\n                    )\r\n                    if (res === false) {\r\n                        result = false\r\n                    }\r\n                    touchPoint.x = touchNewPoint.x\r\n                    touchPoint.y = touchNewPoint.y\r\n                }\r\n                if (result === false) {\r\n                    evt.stopPropagation()\r\n                    evt.preventDefault()\r\n                }\r\n                return result\r\n            },\r\n\r\n            mousedown: evt => {\r\n                touchPoint.x = evt.clientX\r\n                touchPoint.y = evt.clientY\r\n                let result = pointerdown(evt, touchPoint.x, touchPoint.y)\r\n                if (result === false) {\r\n                    evt.stopPropagation()\r\n                    evt.preventDefault()\r\n                }\r\n                return result\r\n            },\r\n\r\n            mouseup: evt => {\r\n                touchPoint.x = evt.clientX\r\n                touchPoint.y = evt.clientY\r\n                let result = pointerup(evt, touchPoint.x, touchPoint.y)\r\n                if (result === false) {\r\n                    evt.stopPropagation()\r\n                    evt.preventDefault()\r\n                }\r\n                return result\r\n            },\r\n\r\n            mousemove: evt => {\r\n                let touchNewPoint = { x: evt.clientX, y: evt.clientY }\r\n                let result = pointermove(evt,\r\n                    touchNewPoint.x,\r\n                    touchNewPoint.y,\r\n                    touchNewPoint.x - touchPoint.x,\r\n                    touchNewPoint.y - touchPoint.y\r\n                )\r\n                touchPoint.x = touchNewPoint.x\r\n                touchPoint.y = touchNewPoint.y\r\n                if (result === false) {\r\n                    evt.stopPropagation()\r\n                    evt.preventDefault()\r\n                }\r\n                return result\r\n            },\r\n\r\n            wheel: evt => {\r\n                const deltaScale = wheelStep * (evt.deltaY > 0 ? 1 : -1) * wheelDirection\r\n                const result = pointerzoom(evt, evt.clientX, evt.clientY, deltaScale)\r\n                if (result === false) {\r\n                    evt.stopPropagation()\r\n                    evt.preventDefault()\r\n                }\r\n                return result\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    enableNativeGestures() {\r\n\r\n        document.removeEventListener('gesturestart', dropEvent)\r\n        document.removeEventListener('gesturechange', dropEvent)\r\n        document.removeEventListener('gestureend', dropEvent)\r\n    }\r\n\r\n    disableNativeGestures() {\r\n\r\n        document.addEventListener('gesturestart', dropEvent)\r\n        document.addEventListener('gesturechange', dropEvent)\r\n        document.addEventListener('gestureend', dropEvent)\r\n    }\r\n\r\n    enableTouchGestures() {\r\n\r\n        this.listenerElement.addEventListener('touchstart', this.listeners.touchstart)\r\n        document.addEventListener('touchend', this.listeners.touchend)\r\n        document.addEventListener('touchmove', this.listeners.touchmove)\r\n    }\r\n\r\n    disableTouchGestures() {\r\n\r\n        this.listenerElement.removeEventListener('touchstart', this.listeners.touchstart)\r\n        document.removeEventListener('touchend', this.listeners.touchend)\r\n        document.removeEventListener('touchmove', this.listeners.touchmove)\r\n    }\r\n\r\n    enableMouseGestures() {\r\n\r\n        this.listenerElement.addEventListener('mousedown', this.listeners.mousedown)\r\n        document.addEventListener('mouseup', this.listeners.mouseup)\r\n        document.addEventListener('mousemove', this.listeners.mousemove)\r\n        this.listenerElement.addEventListener('wheel', this.listeners.wheel)\r\n        document.addEventListener('mouseleave', this.listeners.mouseup) // TODO test it\r\n    }\r\n\r\n    disableMouseGestures() {\r\n\r\n        this.listenerElement.removeEventListener('mousedown', this.listeners.mousedown)\r\n        document.removeEventListener('mouseup', this.listeners.mouseup)\r\n        document.removeEventListener('mousemove', this.listeners.mousemove)\r\n        document.removeEventListener('wheel', this.listeners.wheel)\r\n        document.removeEventListener('mouseleave', this.listeners.mouseup) // TODO test it\r\n    }\r\n}\r\n\r\nTouchGestures.EVT_NAME_POINTERDOWN = EVT_NAME_POINTERDOWN\r\nTouchGestures.EVT_NAME_POINTERMOVE = EVT_NAME_POINTERMOVE\r\nTouchGestures.EVT_NAME_POINTERUP = EVT_NAME_POINTERUP\r\nTouchGestures.EVT_NAME_POINTERZOOM = EVT_NAME_POINTERZOOM\r\n\r\nexport default TouchGestures\r\n", "const isObject = o => typeof o === 'object'\nconst isArray = a => a instanceof Array\n\nexport default function mergeObjects(a, b) {\n    const result = { ...a, ...b }\n    Object.entries(b).forEach(({ 0: k, 1: v }) => {\n        if (k in a && isObject(v) && !isArray(v) && v !== null) {\n            result[k] = mergeObjects(a[k], v)\n        }\n    })\n    return result\n}\n", "import { vec2 } from './vec2.js'\nimport mergeObjects from './mergeObjects.js'\n\nfunction defaultHintsSettings() {\n    return {\n        focus: {\n            points: {\n                innerRadius: dataset => dataset.options.lineWidth * 2,\n                outerRadius: dataset => dataset.options.lineWidth * 2 + dataset.options.lineWidth,\n            },\n            axes: {\n                x: {\n                    color: 'rgba(0,0,0,0.1)',\n                    lineWidth: 1\n                },\n                y: {\n                    color: 'rgba(0,0,0,0.1)',\n                    lineWidth: 1\n                }\n            }\n        },\n        color: {\n            border: 'rgba(0,0,0,0)',\n            background: '#000000',\n            text: '#ffffff',\n        },\n        shadow: {\n            offsetX: 0,\n            offsetY: 15,\n            blur: 5, // 20,\n            color: 'rgba(0,0,0,0.2)',\n        },\n        borderRadius: {\n            leftTop: 5,\n            rightTop: 5,\n            leftBottom: 5,\n            rightBottom: 5\n        },\n        viewportPadding: {\n            left: 15,\n            right: 15,\n            top: 15,\n            bottom: 15\n        },\n        padding: {\n            left: 25,\n            right: 10,\n            top: 5,\n            bottom: 5\n        },\n        mark: {\n            offsetLeft: 15,\n            offsetTop: 15,\n            innerRadius: 0,\n            outerRadius: 3\n        },\n        splitter: {\n            height: 5\n        },\n        unitInvisibleHints: true,\n        maxNumIterations: 20\n    }\n}\n\nconst defaultSettings = defaultHintsSettings()\n\nfunction createHints(ctx, focusPoint, viewport, datasets, opts, helpers) {\n    // settings\n    const { fontFamily, fontSize } = opts\n    const { hintText, settings: passedSettings } = opts.hints\n    const settings = mergeObjects(defaultSettings, passedSettings)\n    const {\n        focus,\n        borderRadius,\n        padding: paddingOrigin,\n        mark: markOrigin,\n        splitter: splitterOrigin\n    } = settings\n    const { innerRadius, outerRadius } = focus.points\n    // create hints\n    const p = vec2()\n    const { transform } = helpers\n    const list = []\n    const pixelRatio = viewport.pixelRatio\n    const mark = { ...markOrigin }\n    mark.offsetLeft *= pixelRatio\n    mark.offsetTop *= pixelRatio\n    mark.innerRadius *= pixelRatio\n    mark.outerRadius *= pixelRatio\n    const padding = { ...paddingOrigin }\n    padding.left *= pixelRatio\n    padding.top *= pixelRatio\n    padding.right *= pixelRatio\n    padding.bottom *= pixelRatio\n    const splitter = { ...splitterOrigin }\n    splitter.height *= pixelRatio\n    const fs = fontSize * pixelRatio\n    ctx.font = `${fs}px/1 ${fontFamily}`\n    for (let i = 0, n = datasets.length; i < n; i ++) {\n        const dataset = datasets[i]\n        const focusPoint = dataset.focusPoint\n        if (focusPoint) {\n            transform(p, focusPoint)\n            const contents = hintText(focusPoint[0], focusPoint[1], dataset, opts, focusPoint.source).split('\\n')\n            let fullWidth = 0\n            let fullHeight = 0\n            let correction = 0\n            for (let j = 0, m = contents.length; j < m; j ++) {\n                const metrics = ctx.measureText(contents[j])\n                const width = metrics.width\n                if (fullWidth < width)\n                    fullWidth = width\n                fullHeight += fs\n                const ascent = -Math.abs(metrics.actualBoundingBoxAscent)\n                const descent = Math.abs(metrics.actualBoundingBoxDescent)\n                correction = fs - (descent - ascent) // TODO\n            }\n            fullHeight += padding.top + padding.bottom + correction // TODO\n            fullWidth += padding.left + padding.right\n            const offsetX = p[0] + 20 // - fullWidth / 2 // TODO use func\n            const offsetY = p[1] - fullHeight / 2 // TODO use func\n            list.push({\n                focusPoints: [{\n                    x: p[0],\n                    y: p[1],\n                    innerRadius: innerRadius(dataset) * pixelRatio,\n                    outerRadius: outerRadius(dataset) * pixelRatio,\n                    dataset\n                }],\n                left: offsetX,\n                top: offsetY,\n                right: offsetX + fullWidth,\n                bottom: offsetY + fullHeight,\n                correction, // TODO\n                texts: [{\n                    offsetLeft: padding.left,\n                    offsetTop: padding.top,\n                    contents\n                }],\n                padding,\n                marks: [{\n                    ...mark,\n                    dataset\n                }]\n            })\n        }\n    }\n    transform(p, focusPoint)\n    return {\n        ctx,\n        focus: {\n            origin: focusPoint,\n            x: p[0],\n            y: p[1]\n        },\n        viewport: {\n            ...viewport,\n            backgroundColor: opts.backgroundColor\n        },\n        settings: mergeObjects(settings, {\n            font: {\n                family: fontFamily,\n                size: fs\n            },\n            borderRadius: borderRadius ? [\n                Math.round(borderRadius.leftTop * pixelRatio),\n                Math.round(borderRadius.rightTop * pixelRatio),\n                Math.round(borderRadius.rightBottom * pixelRatio),\n                Math.round(borderRadius.leftBottom * pixelRatio)\n            ] : null,\n            splitter\n        }),\n        helpers,\n        list\n    }\n}\n\nconst displaceHints = hints => {\n    const { list, settings, viewport: { width, height, pixelRatio }, helpers: { isIntersects } } = hints\n    const { viewportPadding: padding, splitter: { height: splitterHeight } } = settings\n    const viewport = {\n        left: padding.left * pixelRatio,\n        right: width - padding.right * pixelRatio,\n        top: padding.top * pixelRatio,\n        bottom: height - padding.bottom * pixelRatio\n    }\n    let listNext = [ ...list ].sort((a, b) => a.focusPoints[a.focusPoints.length - 1].y - b.focusPoints[0].y)\n    let isChanged = true\n    let numIterations = 0\n    while (isChanged) {\n        numIterations ++\n        isChanged = false\n        for (let i = 0, n = listNext.length; i < n; i ++) {\n            const a = listNext[i]\n            if (a === null) {\n                continue\n            }\n            for (let j = i + 1; j < n; j ++) {\n                const b = listNext[j]\n                if (b === null) {\n                    continue\n                }\n                if (isIntersects(a, b)) {\n                    //const delta = a.bottom - a.top - a.padding.bottom - b.padding.top - b.padding.bottom //+ splitterHeight\n                    const delta = a.bottom - a.top - a.padding.bottom - b.padding.top - a.correction + splitterHeight\n                    for (let k = 0, m = b.texts.length; k < m; k ++) {\n                        b.texts[k].offsetTop += delta\n                    }\n                    for (let k = 0, m = b.marks.length; k < m; k ++) {\n                        b.marks[k].offsetTop += delta\n                    }\n                    a.right = Math.max(a.right, a.left + (b.right - b.left))\n                    a.bottom += (b.bottom - b.top - a.padding.bottom - b.padding.top - a.correction) + splitterHeight\n                    a.texts = a.texts.concat(b.texts)\n                    a.focusPoints = a.focusPoints.concat(b.focusPoints)\n                    a.marks = a.marks.concat(b.marks)\n                    listNext[j] = null\n                    isChanged = true\n                }\n            }\n            listNext[i] = a\n        }\n        if (!settings.unitInvisibleHints) {\n            for (let i = 0, n = listNext.length; i < n; i ++) {\n                const a = listNext[i]\n                if (a === null) {\n                    continue\n                }\n                if (a.right < viewport.left\n                    || a.left > viewport.right\n                    || a.bottom < viewport.top\n                    || a.top > viewport.bottom)\n                {\n                    listNext[i] = null\n                    isChanged = true\n                }\n            }\n        }\n        listNext = listNext.filter(a => a)\n        for (let i = 0, n = listNext.length; i < n; i ++) {\n            const a = listNext[i]\n            if (a.left < viewport.left) {\n                const delta = (viewport.left - a.left)\n                a.left += delta\n                a.right += delta\n                isChanged = true\n            } else if (a.right > viewport.right) {\n                const delta = (a.right - viewport.right)\n                a.left -= delta\n                a.right -= delta\n                isChanged = true\n            }\n            if (a.top < viewport.top) {\n                const delta = (viewport.top - a.top)\n                a.top += delta\n                a.bottom += delta\n                isChanged = true\n            } else if (a.bottom > viewport.bottom) {\n                const delta = (a.bottom - viewport.bottom)\n                a.top -= delta\n                a.bottom -= delta\n                isChanged = true\n            }\n        }\n        if (listNext.length <= 1 || numIterations >= settings.maxNumIterations) {\n            break\n        }\n    }\n    return { ...hints, list: listNext }\n}\n\nconst renderHints = hints => {\n    // settings\n    const {\n        ctx,\n        list,\n        settings: {\n            font,\n            color,\n            shadow,\n            borderRadius,\n            focus: { axes },\n        },\n        viewport: { width, height, pixelRatio, backgroundColor }\n    } = hints\n    // round\n    for (let i = 0, n = list.length; i < n; i ++) {\n        const item = list[i]\n        const { left, top, right, bottom } = item\n        item.rect = {\n            left: Math.round(left),\n            top: Math.round(top),\n            width: Math.round(right - left),\n            height: Math.round(bottom - top),\n        }\n    }\n    // draw focus axes\n    if (axes.y) {\n        const { color, lineWidth } = axes.y\n        ctx.fillStyle = color\n        for (let i = 0, n = list.length; i < n; i ++) {\n            const { focusPoints } = list[i]\n            for (let j = 0, m = focusPoints.length; j < m; j ++) {\n                const { y } = focusPoints[j]\n                ctx.fillRect(0, y, width, Math.round(lineWidth * pixelRatio))\n            }\n        }\n    }\n    if (axes.x) {\n        const { color, lineWidth } = axes.x\n        ctx.fillStyle = color\n        ctx.fillRect(hints.focus.x, 0, Math.round(lineWidth * pixelRatio), height)\n    }\n    // draw shadows\n    if (shadow) {\n        const { offsetX, offsetY, blur, color } = shadow\n        ctx.fillStyle = 'rgb(255,255,255)'\n        ctx.shadowColor = color\n        ctx.shadowOffsetX = offsetX\n        ctx.shadowOffsetY = offsetY\n        ctx.shadowBlur = blur\n        for (let i = 0, n = list.length; i < n; i ++) {\n            const { left, top, width, height } = list[i].rect\n            if (borderRadius) {\n                ctx.beginPath()\n                ctx.roundRect(\n                    left, top, width, height,\n                    borderRadius\n                )\n                ctx.fill()\n            } else {\n                ctx.fillRect(\n                    left, top, width, height\n                )\n            }\n        }\n        ctx.shadowColor = 'transparent'\n    }\n    // draw focus points\n    for (let i = 0, n = list.length; i < n; i ++) {\n        const { focusPoints } = list[i]\n        for (let j = 0, m = focusPoints.length; j < m; j ++) {\n            const { x: xOrigin, y: yOrigin, innerRadius, outerRadius, dataset: { options: { lineColor } } } = focusPoints[j]\n            const x = Math.round(xOrigin)\n            const y = Math.round(yOrigin)\n            ctx.fillStyle = lineColor.toString()\n            ctx.beginPath()\n            ctx.arc(x, y, Math.round(outerRadius), 0, 2 * Math.PI, false)\n            ctx.fill()\n            ctx.fillStyle = backgroundColor\n            ctx.beginPath()\n            ctx.arc(x, y, Math.round(innerRadius), 0, 2 * Math.PI, false)\n            ctx.fill()\n        }\n    }\n    // draw hints\n    const { border, background, text } = color\n    const fs = font.size\n    ctx.font = `${Math.round(fs)}px/1 ${font.family}`\n    for (let i = 0, n = list.length; i < n; i ++) {\n        const { rect: { left, top, width, height }, texts, marks } = list[i]\n        ctx.strokeStyle = border\n        ctx.fillStyle = background\n        if (borderRadius) {\n            ctx.beginPath()\n            ctx.roundRect(\n                left, top, width, height,\n                borderRadius\n            )\n            ctx.fill()\n            ctx.stroke()\n        } else {\n            ctx.fillRect(\n                left, top, width, height\n            )\n        }\n        ctx.fillStyle = text\n        for (let j = 0, m = texts.length; j < m; j ++) {\n            const { offsetLeft, offsetTop, contents } = texts[j]\n            const x = Math.round(offsetLeft + left)\n            let y = offsetTop + top\n            for (let k = 0, l = contents.length; k < l; k ++) {\n                ctx.fillText(\n                    contents[k],\n                    x,\n                    Math.round(y + fs)\n                )\n                y += fs\n            }\n        }\n        for (let j = 0, m = marks.length; j < m; j ++) {\n            const { offsetLeft, offsetTop, innerRadius, outerRadius, dataset: { options: { lineColor } } } = marks[j]\n            const x = Math.round(offsetLeft + left)\n            const y = Math.round(offsetTop + top)\n            ctx.fillStyle = lineColor.toString()\n            ctx.beginPath()\n            ctx.arc(x, y, outerRadius, 0, 2 * Math.PI, false)\n            ctx.fill()\n            ctx.fillStyle = backgroundColor\n            ctx.beginPath()\n            ctx.arc(x, y, innerRadius, 0, 2 * Math.PI, false)\n            ctx.fill()\n        }\n    }\n}\n\nexport {\n    defaultHintsSettings,\n    createHints,\n    displaceHints,\n    renderHints\n}\n", "import mergeObjects from './mergeObjects.js'\n\nfunction defaultLegendsSettings() {\n    return {\n        color: {\n            border: '#eeeeee',\n            background: '#ffffff',\n            text: '#000000',\n        },\n        padding: {\n            left: 5,\n            right: 5,\n            top: 5,\n            bottom: 5\n        },\n        itemPadding: {\n            left: 25,\n            right: 10,\n            top: 5,\n            bottom: 5\n        },\n        mark: {\n            offsetLeft: 15,\n            offsetTop: 15,\n            innerRadius: 0,\n            outerRadius: 3\n        }\n    }\n}\n\nconst defaultSettings = defaultLegendsSettings()\n\nfunction createLegends(ctx, viewport, datasets, opts) {\n    // settings\n    const { legendText, settings: passedSettings } = opts.legends\n    const settings = mergeObjects(defaultSettings, passedSettings)\n    const { itemPadding: itemPaddingOrigin, padding: paddingOrigin, mark: markOrigin } = settings\n    const { fontFamily, fontSize } = opts\n    // create legends\n    let list = []\n    let maxWidth = 0\n    let correction = 0\n    const pixelRatio = viewport.pixelRatio\n    const fs = fontSize * pixelRatio\n    const mark = { ...markOrigin }\n    mark.offsetLeft *= pixelRatio\n    mark.offsetTop *= pixelRatio\n    mark.innerRadius *= pixelRatio\n    mark.outerRadius *= pixelRatio\n    const padding = { ...paddingOrigin }\n    padding.left *= pixelRatio\n    padding.top *= pixelRatio\n    padding.right *= pixelRatio\n    padding.bottom *= pixelRatio\n    const itemPadding = { ...itemPaddingOrigin }\n    itemPadding.left *= pixelRatio\n    itemPadding.top *= pixelRatio\n    itemPadding.right *= pixelRatio\n    itemPadding.bottom *= pixelRatio\n    ctx.font = `${fs}px/1 ${fontFamily}`\n    const legends = [ ...Object.values(datasets.reduce((groups, dataset, i) => {\n        const groupId = dataset.options.groupId === null ? i : dataset.options.groupId\n        if (!(groupId in groups)) {\n            groups[groupId] = { dataset, i }\n        }\n        return groups\n    }, {})) ].sort((a, b) => a.i - b.i)\n    for (let i = 0, n = legends.length; i < n; i ++) {\n        const dataset = legends[i].dataset\n        const content = legendText(dataset, opts)\n        if (content) {\n            const metrics = ctx.measureText(content)\n            const width = metrics.width + itemPadding.left + itemPadding.right * pixelRatio\n            const ascent = -Math.abs(metrics.actualBoundingBoxAscent)\n            const descent = Math.abs(metrics.actualBoundingBoxDescent)\n            correction = Math.max(correction, fs - (descent - ascent)) // TODO\n            list.push({\n                text: {\n                    content,\n                    offsetLeft: itemPadding.left,\n                    offsetTop: itemPadding.top,\n                },\n                mark,\n                lineColor: dataset.options.lineColor,\n                width,\n                left: 0,\n                top: 0\n            })\n            if (maxWidth < width) {\n                maxWidth = width\n            }\n        }\n    }\n// list = [ ...list.map(item => ({ ...item })), ...list.map(item => ({ ...item })), ...list.map(item => ({ ...item })), ...list.map(item => ({ ...item })), ...list.map(item => ({ ...item })) ]\n    // displace legends\n    const availWidth = viewport.width - padding.left - padding.right\n    const numColumns = Math.floor(availWidth / maxWidth)\n// const numColumns = 2\n    let maxColumnsUsed = 0\n    let maxRowsUsed = 0\n    const rowHeight = fs + itemPadding.top + itemPadding.bottom + correction\n    for (let i = 0, n = list.length; i < n; i ++) {\n        const item = list[i]\n        const columnIndex = i % numColumns\n        const rowIndex = Math.floor(i / numColumns)\n        if (maxColumnsUsed < columnIndex) {\n            maxColumnsUsed = columnIndex\n        }\n        if (maxRowsUsed < rowIndex) {\n            maxRowsUsed = rowIndex\n        }\n        item.left = columnIndex * maxWidth\n        item.top = rowIndex * rowHeight\n    }\n    const legendsHeight = (maxRowsUsed + 1) * rowHeight + padding.top + padding.bottom\n    const shiftX = padding.left + (availWidth - (maxColumnsUsed + 1) * maxWidth) / 2\n    const shiftY = viewport.height - legendsHeight + padding.top\n    for (let i = 0, n = list.length; i < n; i ++) {\n        const item = list[i]\n        item.left += shiftX\n        item.top += shiftY\n    }\n    // clip viewport\n    viewport.clip(0, 0, viewport.width, viewport.height - legendsHeight)\n    // result\n    return {\n        ctx,\n        // rowHeight,\n        area: {\n            left: 0,\n            right: viewport.width,\n            top: viewport.height - legendsHeight,\n            bottom: viewport.height\n        },\n        viewport: {\n            ...viewport,\n            backgroundColor: opts.backgroundColor\n        },\n        settings: mergeObjects(settings, {\n            font: {\n                family: fontFamily,\n                size: fs\n            }\n        }),\n        list\n    }\n}\n\nfunction renderLegends(legends) {\n    // settings\n    const {\n        ctx,\n        // rowHeight,\n        area,\n        settings: { font, color },\n        viewport: { pixelRatio, backgroundColor },\n        list\n    } = legends\n    // variables\n    // draw area\n    if (color.background) {\n        const left = Math.round(area.left)\n        const top = Math.round(area.top)\n        const right = Math.round(area.right)\n        const bottom = Math.round(area.bottom)    \n        ctx.fillStyle = color.background\n        ctx.fillRect(\n            left,\n            top,\n            right - left,\n            bottom - top\n        )\n        if (color.border) {\n            ctx.fillStyle = color.border\n            ctx.fillRect(\n                left,\n                top,\n                right - left,\n                Math.round(1 * pixelRatio)\n            )\n        }\n    }\n    // draw legends\n    const fs = font.size\n    ctx.font = `${Math.round(fs)}px/1 ${font.family}`\n    for (let i = 0, n = list.length; i < n; i ++) {\n        let { left, top, text, mark, lineColor } = list[i]\n// ctx.fillStyle = 'rgba(255,0,0,0.1)'\n// ctx.fillRect(left,top,list[i].width,rowHeight)\n        ctx.fillStyle = color.text\n        {\n            let { offsetLeft, offsetTop, content } = text\n            offsetLeft += left\n            offsetTop += top\n            ctx.fillText(\n                content,\n                Math.round(offsetLeft),\n                Math.round(offsetTop + font.size)\n            )\n        }\n        {\n            const { offsetLeft, offsetTop, innerRadius, outerRadius } = mark\n            const x = Math.round(offsetLeft + left)\n            const y = Math.round(offsetTop + top)\n            ctx.fillStyle = lineColor.toString()\n            ctx.beginPath()\n            ctx.arc(x, y, Math.round(outerRadius), 0, 2 * Math.PI, false)\n            ctx.fill()\n            ctx.fillStyle = backgroundColor\n            ctx.beginPath()\n            ctx.arc(x, y, Math.round(innerRadius), 0, 2 * Math.PI, false)\n            ctx.fill()\n        }\n    }\n}\n\nexport {\n    defaultLegendsSettings,\n    createLegends,\n    renderLegends\n}\n", "import { isZero, vec2, vec2copy, vec2add, vec2sub, vec2mul, vec2div, vec2muladd, vec2neglerp, vec2subdiv, vec2lerp, vec2clone } from './vec2.js'\r\nimport { findLess } from './BinarySearch.js'\r\nimport TouchGestures from './TouchGestures.js'\r\nimport { defaultHintsSettings, createHints, displaceHints, renderHints } from './Hints.js'\r\nimport { defaultLegendsSettings, createLegends, renderLegends } from './Legends.js'\r\nimport mergeObjects from './mergeObjects.js'\r\n\r\nfunction isIntersects(r1, r2) {\r\n    return r1.bottom > r2.top \r\n        && r1.right > r2.left \r\n        && r1.top < r2.bottom \r\n        && r1.left < r2.right\r\n}\r\n\r\nfunction isNodesIntersects(nodes) { // TODO optimize, test only half of array\r\n    const n = nodes.length \r\n    for (let i = 0; i < n; i ++) {\r\n        for (let j = 0; j < n; j ++) {\r\n            if (i === j) {\r\n                continue\r\n            }\r\n            if (isIntersects(nodes[i].boundingRect, nodes[j].boundingRect)) {\r\n                return true\r\n            }\r\n        }\r\n    }\r\n    return false\r\n}\r\n\r\nconst defaultOptions = {\r\n    xCanvasStep: 25,\r\n    yCanvasStep: 25,\r\n    xAxisStep: 1,\r\n    yAxisStep: 1,\r\n    xOffset: 0,\r\n    yOffset: 0,\r\n    xScale: 1,\r\n    yScale: 1,\r\n    xAxisSubdivisions: 10.0,\r\n    yAxisSubdivisions: 10.0,\r\n    lineWidth: 1,\r\n    pointSize: 0,\r\n    fontSize: 15,\r\n    fontFamily: 'monospace',\r\n    xAxisLabelXOffset: 0,\r\n    xAxisLabelYOffset: 0,\r\n    xAxisLabelDynamicPosition: true,\r\n    xAxisLabelSpacing: 15,\r\n    xAxisLabelFormat: x => x.toFixed(4),\r\n    xAxisLabelJoiningStep: 5.0,\r\n    xAxisLabelMarkOffset: -2,\r\n    xAxisLabelMarkSize: 4,\r\n    xAxisLabelDisplayZero: true,\r\n    xAxisLabelEnable: true,\r\n    yAxisLabelXOffset: 0,\r\n    yAxisLabelYOffset: 0,\r\n    yAxisLabelDynamicPosition: true,\r\n    yAxisLabelSpacing: 0,\r\n    yAxisLabelFormat: y => y.toFixed(4),\r\n    yAxisLabelJoiningStep: 5.0,\r\n    yAxisLabelMarkOffset: -2,\r\n    yAxisLabelMarkSize: 4,\r\n    yAxisLabelDisplayZero: true,\r\n    yAxisLabelEnable: true,\r\n    backgroundColor: '#ffffff',\r\n    gridColor: 'rgba(0,0,0,0.1)',\r\n    axesColor: 'rgba(0,0,0,0.5)',\r\n    userTranslateX: true,\r\n    userTranslateY: true,\r\n    userScaleX: true,\r\n    userScaleY: true,\r\n    canvasRatio: 1,\r\n    canvasPixelRatio: 1,\r\n    clearFrame: false,\r\n    hints: {\r\n        settings: defaultHintsSettings(),\r\n        hintText: (x, y, dataset, opts, pointSource) => `X: ${opts.xAxisLabelFormat(x)}\\nY: ${opts.yAxisLabelFormat(y)}`,\r\n        createHints,\r\n        displaceHints,\r\n        renderHints,\r\n    },\r\n    legends: {\r\n        settings: defaultLegendsSettings(),\r\n        legendText: (dataset, opts) => `${dataset.legend}`,\r\n        createLegends,\r\n        renderLegends,\r\n    },\r\n    cursorPointer: 'pointer',\r\n    cursorGrabbing: 'grabbing',\r\n    bindEventHandlers: true,\r\n    invertMouseWheel: false,\r\n    mouseWheelStep: 0.1,\r\n    afterRepaint: null\r\n}\r\n\r\nclass Chart {\r\n\r\n    constructor(elCanvas, options = {}) {\r\n\r\n        this.options = options = mergeObjects(defaultOptions, options)\r\n        this.elCanvas = elCanvas\r\n        this.ctx = elCanvas.getContext('2d')\r\n        this.scale = vec2(options.xScale, options.yScale)\r\n        this.translate = vec2(options.xOffset, options.yOffset)\r\n        this.focusPoint = vec2(0, 0)\r\n        this.datasets = []\r\n        this.currentXBounds = vec2()\r\n\r\n        elCanvas.style.cursor = options.cursorPointer\r\n\r\n        const mouseState = {\r\n            down: false,\r\n            pt0: vec2(0, 0),\r\n            pt: vec2(0, 0),\r\n            delta: vec2(0, 0)\r\n        }\r\n\r\n        const pointFromMouseEvent = (r, evt) => {\r\n            const { clientX: x, clientY: y } = evt\r\n            const { left, right, top, bottom } = elCanvas.getBoundingClientRect()\r\n            r[0] = (x - left) / options.canvasRatio\r\n            r[1] = (y - top) / options.canvasRatio\r\n            const isInsideCanvas = left <= x && x <= right\r\n                && top <= y && y <= bottom\r\n            return isInsideCanvas\r\n        }\r\n\r\n        this.isListening = false\r\n        this.listeners = { }\r\n        this.listeners[TouchGestures.EVT_NAME_POINTERDOWN] = evt => {\r\n            elCanvas.style.cursor = options.cursorGrabbing\r\n            evt.detail.originalEvent.preventDefault()\r\n            mouseState.down = true\r\n            pointFromMouseEvent(mouseState.pt0, evt.detail)\r\n        }\r\n        this.listeners[TouchGestures.EVT_NAME_POINTERUP] = evt => {\r\n            mouseState.down = false\r\n            elCanvas.style.cursor = options.cursorPointer\r\n        }\r\n        this.listeners[TouchGestures.EVT_NAME_POINTERMOVE] = evt => {\r\n            const isInsideCanvas = pointFromMouseEvent(mouseState.pt, evt.detail)\r\n            if (mouseState.down) {\r\n                vec2sub(mouseState.delta, mouseState.pt, mouseState.pt0)\r\n                vec2copy(mouseState.pt0, mouseState.pt)\r\n                const delta = vec2(\r\n                    options.userTranslateX ? mouseState.delta[0] : 0,\r\n                    options.userTranslateY ? mouseState.delta[1] : 0\r\n                )\r\n                this.move(delta)\r\n                this.repaint()\r\n            } else if (isInsideCanvas) {\r\n                const r = vec2()\r\n                vec2subdiv(r, mouseState.pt, vec2(options.xCanvasStep, options.yCanvasStep), this.translate)\r\n                r[1] = -r[1]\r\n                vec2mul(r, r, vec2(options.xAxisStep, options.yAxisStep))\r\n                vec2div(r, r, this.scale)\r\n                this.computeFocusPoints(r)\r\n                this.repaint()\r\n            }\r\n        }\r\n        this.listeners[TouchGestures.EVT_NAME_POINTERZOOM] = evt => {\r\n            evt.detail.originalEvent.preventDefault()\r\n            const deltaScale = evt.detail.deltaScale\r\n            const doScaleX = options.userScaleX === true\r\n                || (typeof options.userScaleX === 'function' && options.userScaleX(evt))\r\n            const doScaleY = options.userScaleY === true\r\n                || (typeof options.userScaleY === 'function' && options.userScaleY(evt))\r\n            const delta = vec2(\r\n                doScaleX ? deltaScale : 0,\r\n                doScaleY ? deltaScale : 0\r\n            )\r\n            pointFromMouseEvent(mouseState.pt, evt.detail)\r\n            this.zoomAroundPoint(delta, mouseState.pt)\r\n            this.repaint()\r\n        }\r\n\r\n        this.touchGestures = new TouchGestures(elCanvas, {\r\n            invertMouseWheel: options.invertMouseWheel,\r\n            mouseWheelStep: options.mouseWheelStep\r\n        })\r\n\r\n        if (options.bindEventHandlers) {\r\n            this.bind()\r\n        }\r\n    }\r\n\r\n    computeFocusPoints(p) {\r\n\r\n        this.datasets.forEach(dataset => {\r\n            const { source } = dataset\r\n            const length = source.length\r\n            const i0 = findLess(i => source.at(i)[0], 0, length - 1, p[0])\r\n            const i1 = i0 + 1\r\n            if (i0 >= 0 && i1 < length) {\r\n                const r = vec2()\r\n                const p1 = source.at(i0)\r\n                const p2 = source.at(i1)\r\n                const t = (p[0] - p1[0]) / (p2[0] - p1[0])\r\n                const s = vec2(t, dataset.options.isStepped ? 0 : t)\r\n                vec2lerp(r, p1, p2, s)\r\n                r.source = { i0, i1, s }\r\n                dataset.focusPoint = r\r\n            } else {\r\n                dataset.focusPoint = null\r\n            }\r\n        })\r\n        vec2copy(this.focusPoint, p)\r\n    }\r\n\r\n    bind() {\r\n\r\n        if (this.isListening) {\r\n            return\r\n        }\r\n\r\n        for (let evtName in this.listeners) {\r\n            this.elCanvas.addEventListener(evtName, this.listeners[evtName])\r\n        }\r\n        this.touchGestures.enableTouchGestures()\r\n        this.touchGestures.enableMouseGestures()\r\n        \r\n        this.isListening = true\r\n    }\r\n\r\n    unbind() {\r\n\r\n        if (!this.isListening) {\r\n            return\r\n        }\r\n\r\n        for (let evtName in this.listeners) {\r\n            this.elCanvas.removeEventListener(evtName, this.listeners[evtName])\r\n        }\r\n        this.touchGestures.disableTouchGestures()\r\n        this.touchGestures.disableMouseGestures()\r\n\r\n        this.isListening = false\r\n    }\r\n\r\n    getViewportXBounds() {\r\n\r\n        return vec2clone(this.currentXBounds)\r\n    }\r\n\r\n    fitView(boundingRect, keepAspectRatio = true) { \r\n\r\n        let w = this.elCanvas.width\r\n        let h = this.elCanvas.height\r\n\r\n        if (w <= 0 || h <= 0 || Math.abs(boundingRect.width) <= 0 || Math.abs(boundingRect.height) <= 0) {\r\n            return false\r\n        }\r\n\r\n        const opts = this.options\r\n\r\n        if (opts.legends) {\r\n            opts.legends.createLegends(\r\n                this.ctx,\r\n                {\r\n                    width: w,\r\n                    height: h,\r\n                    pixelRatio: opts.canvasRatio * opts.canvasPixelRatio,\r\n                    clip(left, top, right, bottom) {\r\n                        w = right - left\r\n                        h = bottom - top\r\n                        // TODO left, top is not used later\r\n                    }\r\n                },\r\n                this.datasets,\r\n                opts,\r\n                {\r\n                    isIntersects,\r\n                    // measureText: text => ctx.measureText(text)\r\n                }\r\n            )\r\n        }\r\n\r\n        const bRect = new DOMRect( // flip by Y\r\n            boundingRect.x,\r\n            -boundingRect.y - boundingRect.height,\r\n            boundingRect.width,\r\n            boundingRect.height\r\n        )\r\n\r\n        const px = opts.canvasRatio * opts.canvasPixelRatio\r\n        const canvasStep = vec2(opts.xCanvasStep, opts.yCanvasStep)\r\n        const axesStep = vec2(opts.xAxisStep, opts.yAxisStep)\r\n        w = (w / px / canvasStep[0]) * axesStep[0]\r\n        h = (h / px / canvasStep[1]) * axesStep[1]\r\n\r\n        this.scale[0] = w / bRect.width\r\n        this.scale[1] = h / bRect.height\r\n        if (keepAspectRatio) {\r\n            if (this.scale[1] > this.scale[0]) {\r\n                this.scale[1] = this.scale[0]\r\n            } else {\r\n                this.scale[0] = this.scale[1]\r\n            }\r\n        }\r\n\r\n        this.translate[0] = -(bRect.x / axesStep[0]) * canvasStep[0] * this.scale[0]\r\n        this.translate[1] = -(bRect.y / axesStep[1]) * canvasStep[1] * this.scale[1]\r\n        if (keepAspectRatio) {\r\n            const dw = (w / this.scale[0] - bRect.width) / 2\r\n            const dh = (h / this.scale[1] - bRect.height) / 2\r\n            this.translate[0] += dw * canvasStep[0] * this.scale[0] / axesStep[0]\r\n            this.translate[1] += dh * canvasStep[1] * this.scale[1] / axesStep[1]\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    fitViewAuto(keepAspectRatio = true) {\r\n\r\n        this.fitView(this.getBoundingRect(null, 0, null, 0), keepAspectRatio)\r\n        this.repaint()\r\n    }\r\n\r\n    getExtrems(initialMinX = null, initialMinY = null, initialMaxX = null, initialMaxY = null) {\r\n\r\n        let minX = initialMinX\r\n        let maxX = initialMaxX\r\n        let minY = initialMinY\r\n        let maxY = initialMaxY\r\n\r\n        this.datasets.forEach(dataset => {\r\n            const extrems = dataset.getExtrems()\r\n            if (minX === null || minX > extrems.minX) {\r\n                minX = extrems.minX\r\n            }\r\n            if (maxX === null || maxX < extrems.maxX) {\r\n                maxX = extrems.maxX\r\n            }\r\n            if (minY === null || minY > extrems.minY) {\r\n                minY = extrems.minY\r\n            }\r\n            if (maxY === null || maxY < extrems.maxY) {\r\n                maxY = extrems.maxY\r\n            }\r\n        })\r\n\r\n        return { minX, minY, maxX, maxY }\r\n    }\r\n\r\n    getBoundingRect(initialMinX = null, initialMinY = null, initialMaxX = null, initialMaxY = null) { // DEPRECATED\r\n\r\n        const { minX, minY, maxX, maxY } = this.getExtrems()\r\n\r\n        const rect = new DOMRect(minX, minY, maxX - minX, maxY - minY)\r\n        rect.minX = minX\r\n        rect.minY = minY\r\n        rect.maxX = maxX\r\n        rect.maxY = maxY\r\n        \r\n        return rect\r\n    }\r\n\r\n    move(delta) {\r\n\r\n        vec2add(this.translate, this.translate, delta)\r\n    }\r\n\r\n    zoomAroundPoint(deltaScale, pt) {\r\n\r\n        const o = this.translate\r\n        const s = this.scale\r\n\r\n        vec2neglerp(o, o, pt, deltaScale)\r\n        vec2muladd(s, s, deltaScale, s)\r\n    }\r\n\r\n    repaint() {\r\n\r\n        let x\r\n        let y\r\n\r\n        const opts = this.options\r\n        const ctx = this.ctx\r\n        let w = this.elCanvas.width\r\n        let h = this.elCanvas.height\r\n        const s = this.scale\r\n        const datasets = this.datasets\r\n\r\n        if (w <= 0 || h <= 0 || s[0] === 0 || s[1] === 0) {\r\n            return\r\n        }\r\n\r\n        const px = opts.canvasRatio * opts.canvasPixelRatio\r\n        const canvasStep = vec2(opts.xCanvasStep * px, opts.yCanvasStep * px)\r\n\r\n        const o = vec2(this.translate[0] * px, this.translate[1] * px)\r\n        const su = vec2(canvasStep[0] * s[0], canvasStep[1] * s[1])\r\n        const u = vec2(opts.xAxisStep, opts.yAxisStep)\r\n        const gridScale = vec2(1, 1)\r\n        const subdivisions = vec2(opts.xAxisSubdivisions, opts.yAxisSubdivisions)\r\n        \r\n        while (su[0] > canvasStep[0] * subdivisions[0]) { // TODO optimize, remove loop\r\n            su[0] /= subdivisions[0]\r\n            gridScale[0] /= subdivisions[0]\r\n        }\r\n        while (su[1] > canvasStep[1] * subdivisions[1]) { // TODO optimize, remove loop\r\n            su[1] /= subdivisions[1]\r\n            gridScale[1] /= subdivisions[1]\r\n        }\r\n        while (su[0] < canvasStep[0]) { // TODO optimize, remove loop\r\n            su[0] *= subdivisions[0]\r\n            gridScale[0] *= subdivisions[0]\r\n        }\r\n        while (su[1] < canvasStep[1]) { // TODO optimize, remove loop\r\n            su[1] *= subdivisions[1]\r\n            gridScale[1] *= subdivisions[1]\r\n        }\r\n\r\n        const stx = o[0] - (Math.floor(o[0] / su[0]) + (o[0] > 0 ? 1 : 0)) * su[0]\r\n        const sty = o[1] - (Math.floor(o[1] / su[1]) + (o[1] > 0 ? 1 : 0)) * su[1]\r\n\r\n        const transform = (r, p) => {\r\n            vec2mul(r, p, canvasStep)\r\n            vec2div(r, r, u)\r\n            r[1] = -r[1]\r\n            vec2muladd(r, r, s, o)\r\n        }\r\n\r\n        // clear\r\n        if (opts.clearFrame) {\r\n            ctx.clearRect(0, 0, w, h)\r\n        }\r\n        ctx.fillStyle = opts.backgroundColor\r\n        ctx.fillRect(0, 0, w, h)\r\n\r\n        let clipPath = null\r\n\r\n        // draw legends\r\n        if (opts.legends) {\r\n            const { createLegends, renderLegends } = opts.legends\r\n            const legends = createLegends(\r\n                ctx,\r\n                {\r\n                    width: w,\r\n                    height: h,\r\n                    pixelRatio: px,\r\n                    clip(left, top, right, bottom) {\r\n                        w = right - left\r\n                        h = bottom - top\r\n                        clipPath = new Path2D()\r\n                        clipPath.rect(left, top, w, h)\r\n                    }\r\n                },\r\n                datasets,\r\n                opts,\r\n                {\r\n                    isIntersects,\r\n                    // measureText: text => ctx.measureText(text)\r\n                }\r\n            )\r\n            renderLegends(legends)\r\n        }\r\n\r\n        // clip\r\n        if (clipPath) {\r\n            ctx.save()\r\n            ctx.clip(clipPath)\r\n        }\r\n\r\n        // draw grid\r\n        ctx.fillStyle = opts.gridColor\r\n        for (let x = stx; x <= w; x += su[0]) {\r\n            ctx.fillRect(x, 0, 1 * px, h)\r\n        }\r\n        for (let y = sty; y <= h; y += su[1]) {\r\n            ctx.fillRect(0, y, w, 1 * px)\r\n        }\r\n\r\n        // draw axes\r\n        ctx.fillStyle = opts.axesColor\r\n        ctx.fillRect(o[0], 0, 1 * px, h)\r\n        ctx.fillRect(0, o[1], w, 1 * px)\r\n\r\n        // draw datasets\r\n        for (let i = 0, n = datasets.length; i < n; i ++) {\r\n            const dataset = datasets[i]\r\n            const { source, tree } = dataset\r\n\r\n            if (source.length > 1) {\r\n                ctx.strokeStyle = dataset.options.lineColor\r\n                ctx.lineWidth = dataset.options.lineWidth * px\r\n\r\n                const p0 = vec2()\r\n                const p1 = vec2()\r\n\r\n                const renderNode = (ctx, node, source) => {\r\n                    transform(p1, [ node.maxX, node.maxY ])\r\n                    if (p1[0] < 0) { return }\r\n                    transform(p0, [ node.minX, node.minY ])\r\n                    if (p0[0] > w) { return }\r\n                    const x0 = Math.round(p0[0])\r\n                    const x1 = Math.round(p1[0])\r\n                    if (x0 === x1) {\r\n                        ctx.beginPath()\r\n                        ctx.setLineDash(dataset.options.lineDash.map(x => x * px))\r\n                        ctx.moveTo(x0, p0[1])\r\n                        ctx.lineTo(x1, p1[1])\r\n                        ctx.stroke()\r\n                    } else if (node.left && node.right) {\r\n                        renderNode(ctx, node.left, source)\r\n                        renderNode(ctx, node.right, source)\r\n                    } else {\r\n                        ctx.beginPath()\r\n                        ctx.setLineDash(dataset.options.lineDash.map(x => x * px))\r\n                        transform(p0, source.at(node.s))\r\n                        ctx.moveTo(p0[0], p0[1])\r\n                        for (let j = node.s + 1; j <= node.e; j ++) { // TODO use source.forEach\r\n                            transform(p0, source.at(j))\r\n                            ctx.lineTo(p0[0], p0[1])\r\n                        }\r\n                        ctx.stroke()\r\n                    }\r\n                    ctx.setLineDash([])\r\n                }\r\n\r\n                const renderNodeStepped = (ctx, node, source) => {\r\n                    transform(p1, [ node.maxX, node.maxY ])\r\n                    if (p1[0] < 0) { return }\r\n                    transform(p0, [ node.minX, node.minY ])\r\n                    if (p0[0] > w) { return }\r\n                    const x0 = Math.round(p0[0])\r\n                    const x1 = Math.round(p1[0])\r\n                    if (x0 === x1) {\r\n                        ctx.beginPath()\r\n                        ctx.setLineDash(dataset.options.lineDash.map(x => x * px))\r\n                        ctx.moveTo(x0, p0[1])\r\n                        ctx.lineTo(x1, p1[1])\r\n                        ctx.stroke()\r\n                    } else if (node.left && node.right) {\r\n                        renderNodeStepped(ctx, node.left, source)\r\n                        renderNodeStepped(ctx, node.right, source)\r\n                    } else {\r\n                        ctx.beginPath()\r\n                        ctx.setLineDash(dataset.options.lineDash.map(x => x * px))\r\n                        transform(p0, source.at(node.s))\r\n                        ctx.moveTo(p0[0], p0[1])\r\n                        let y = p0[1]\r\n                        for (let j = node.s + 1; j <= node.e; j ++) { // TODO use source.forEach\r\n                            transform(p0, source.at(j))\r\n                            ctx.lineTo(p0[0], y)\r\n                            ctx.lineTo(p0[0], p0[1])\r\n                            y = p0[1]\r\n                        }\r\n                        ctx.stroke()\r\n                    }\r\n                    ctx.setLineDash([])\r\n                }\r\n\r\n                const PI2 = 2 * Math.PI\r\n\r\n                const renderNodePoints = (ctx, node, source, r) => {\r\n                    transform(p1, [ node.maxX, node.maxY ])\r\n                    if (p1[0] < 0) { return }\r\n                    transform(p0, [ node.minX, node.minY ])\r\n                    if (p0[0] > w) { return }\r\n                    const x0 = Math.round(p0[0])\r\n                    const x1 = Math.round(p1[0])\r\n                    if (x0 === x1) {\r\n                        ctx.beginPath()\r\n                        ctx.arc(x0, p0[1], r, 0, PI2, false)\r\n                        ctx.fill()\r\n                        ctx.beginPath()\r\n                        ctx.arc(x1, p1[1], r, 0, PI2, false)\r\n                        ctx.stroke()\r\n                    } else if (node.left && node.right) {\r\n                        renderNodePoints(ctx, node.left, source, r)\r\n                        renderNodePoints(ctx, node.right, source, r)\r\n                    } else {\r\n                        for (let j = node.s; j <= node.e; j ++) {\r\n                            transform(p0, source.at(j))\r\n                            ctx.beginPath()\r\n                            ctx.arc(p0[0], p0[1], r, 0, PI2, false)\r\n                            ctx.fill()\r\n                        }\r\n                        ctx.stroke()\r\n                    }\r\n                }\r\n\r\n                if (dataset.options.isStepped) {\r\n                    renderNodeStepped(ctx, tree, source)\r\n                } else {\r\n                    renderNode(ctx, tree, source)\r\n                }\r\n                const r = dataset.options.pointRadius\r\n                if (r > 0) {\r\n                    ctx.fillStyle = dataset.options.lineColor\r\n                    renderNodePoints(ctx, tree, source, r)\r\n                }\r\n            }\r\n        }\r\n\r\n        // draw labels\r\n        if (opts.xAxisLabelEnable || opts.yAxisLabelEnable) {\r\n            const fs = opts.fontSize * px\r\n            ctx.font = `${fs}px/1 ${opts.fontFamily}`\r\n            ctx.fillStyle = opts.axesColor\r\n            this.currentXBounds[0] = (0 - o[0]) / su[0] * gridScale[0] * u[0]\r\n            this.currentXBounds[1] = (w - o[0]) / su[0] * gridScale[0] * u[0]\r\n            if (opts.xAxisLabelEnable) {\r\n                const xOffset = opts.xAxisLabelXOffset * px\r\n                const yOffset = opts.xAxisLabelYOffset * px\r\n                const markOffset = opts.xAxisLabelMarkOffset * px\r\n                const markSize = opts.xAxisLabelMarkSize * px\r\n                const spacing = opts.xAxisLabelSpacing * px\r\n                const halfSpacing = spacing / 2\r\n                let labels = []\r\n                let labelsOutOfTopBound = false\r\n                let labelsOutOfBottomBound = false\r\n                for (let x = stx; x <= w; x += su[0]) {\r\n                    const delta = x - o[0]\r\n                    const i = Math.round(delta / su[0]) // index of grid line\r\n                    const t = i * gridScale[0] // parametric value of grid line\r\n                    const v = t * u[0] // value of grid line\r\n                    const text = opts.xAxisLabelFormat(v)\r\n                    const textMetrics = ctx.measureText(text)\r\n                    const label = {\r\n                        i,\r\n                        gridX: x,\r\n                        text,\r\n                        textMetrics,\r\n                        x: x - textMetrics.width / 2 + xOffset,\r\n                        y: o[1] + fs + yOffset\r\n                    }\r\n                    labels.push(label)\r\n                    if (label.y - fs - yOffset < 0) {\r\n                        labelsOutOfTopBound = true\r\n                    }\r\n                    if (label.y + yOffset > h) {\r\n                        labelsOutOfBottomBound = true\r\n                    }\r\n                }\r\n                for (let i = 0, n = labels.length; i < n; i ++) { // TODO compute y once for all x-labels\r\n                    const label = labels[i]\r\n                    y = label.y\r\n                    if (opts.xAxisLabelDynamicPosition) {\r\n                        y = labelsOutOfTopBound\r\n                            ? fs + yOffset\r\n                            : labelsOutOfBottomBound\r\n                                ? h - yOffset\r\n                                : y\r\n                    }\r\n                    const boundingRect = new DOMRect(\r\n                        label.x - halfSpacing,\r\n                        y - fs,\r\n                        label.textMetrics.width + spacing,\r\n                        fs\r\n                    )\r\n                    label.y = y\r\n                    label.boundingRect = boundingRect\r\n                }\r\n                // remove intersected labels\r\n                let joiningStep = opts.xAxisLabelJoiningStep\r\n                let srcLabels = labels\r\n                while (isNodesIntersects(labels)) {\r\n                    labels = srcLabels.filter(label => isZero(Math.abs(label.i) % joiningStep))\r\n                    joiningStep += opts.xAxisLabelJoiningStep\r\n                }\r\n                // render labels\r\n                for (let i = 0, n = labels.length; i < n; i ++) {\r\n                    const label = labels[i]\r\n                    if (!opts.xAxisLabelDisplayZero && label.i === 0) {\r\n                        continue\r\n                    }\r\n                    ctx.fillRect(label.gridX, o[1] + markOffset, px, markSize)\r\n                    ctx.fillText(\r\n                        label.text,\r\n                        label.x,\r\n                        label.y\r\n                    )\r\n                }\r\n            }\r\n            if (opts.yAxisLabelEnable) {\r\n                const xOffset = opts.yAxisLabelXOffset * px\r\n                const yOffset = opts.yAxisLabelYOffset * px\r\n                const markOffset = opts.yAxisLabelMarkOffset * px\r\n                const markSize = opts.yAxisLabelMarkSize * px\r\n                const spacing = opts.yAxisLabelSpacing * px\r\n                const halfSpacing = spacing / 2\r\n                let labels = []\r\n                let maxWidth = 0\r\n                let labelsOutOfLeftBound = false\r\n                let labelsOutOfRightBound = false\r\n                for (let y = sty; y <= h; y += su[1]) {\r\n                    const delta = o[1] - y\r\n                    const i = Math.round(delta / su[1]) // index of grid line\r\n                    const t = i * gridScale[1] // parametric value of grid line\r\n                    const v = t * u[1] // value of grid line\r\n                    const text = opts.yAxisLabelFormat(v)\r\n                    const textMetrics = ctx.measureText(text)\r\n                    const label = {\r\n                        i,\r\n                        gridY: y,\r\n                        text,\r\n                        textMetrics,\r\n                        x: o[0] - textMetrics.width + xOffset,\r\n                        y: y + fs/2 + yOffset\r\n                    }\r\n                    labels.push(label)\r\n                    if (maxWidth < textMetrics.width) {\r\n                        maxWidth = textMetrics.width\r\n                    }\r\n                    if (label.x + xOffset < 0) {\r\n                        labelsOutOfLeftBound = true\r\n                    }\r\n                    if (label.x + label.textMetrics.width - xOffset > w) {\r\n                        labelsOutOfRightBound = true\r\n                    }\r\n                }\r\n                for (let i = 0, n = labels.length; i < n; i ++) { // TODO compute x once for all y-labels\r\n                    const label = labels[i]\r\n                    x = label.x\r\n                    if (opts.yAxisLabelDynamicPosition) {\r\n                        x = labelsOutOfLeftBound\r\n                            ? maxWidth - label.textMetrics.width - xOffset\r\n                            : labelsOutOfRightBound\r\n                                ? w - label.textMetrics.width + xOffset\r\n                                : x\r\n                    }\r\n                    const boundingRect = new DOMRect(\r\n                        x,\r\n                        label.y - fs - halfSpacing,\r\n                        label.textMetrics.width,\r\n                        fs + spacing\r\n                    )\r\n                    label.x = x\r\n                    label.boundingRect = boundingRect\r\n                }\r\n                // remove intersected labels\r\n                let joiningStep = opts.yAxisLabelJoiningStep\r\n                let srcLabels = labels\r\n                while (isNodesIntersects(labels)) {\r\n                    labels = srcLabels.filter(label => isZero(Math.abs(label.i) % joiningStep))\r\n                    joiningStep += opts.yAxisLabelJoiningStep\r\n                }\r\n                labels = labels.filter(label => label.boundingRect.bottom > 0 && label.boundingRect.top < h)\r\n                // recompute intersections after removing intersected labels\r\n                maxWidth = 0\r\n                labelsOutOfLeftBound = false\r\n                labelsOutOfRightBound = false\r\n                for (let i = 0, n = labels.length; i < n; i ++) {\r\n                    const label = labels[i]\r\n                    label.x = o[0] - label.textMetrics.width + xOffset\r\n                    if (maxWidth < label.textMetrics.width) {\r\n                        maxWidth = label.textMetrics.width\r\n                    }\r\n                    if (label.x + xOffset < 0) {\r\n                        labelsOutOfLeftBound = true\r\n                    }\r\n                    if (label.x + label.textMetrics.width - xOffset > w) {\r\n                        labelsOutOfRightBound = true\r\n                    }\r\n                }\r\n                for (let i = 0, n = labels.length; i < n; i ++) { // TODO compute x once for all y-labels\r\n                    const label = labels[i]\r\n                    x = label.x\r\n                    if (opts.yAxisLabelDynamicPosition) {\r\n                        x = labelsOutOfLeftBound\r\n                            ? maxWidth - label.textMetrics.width - xOffset\r\n                            : labelsOutOfRightBound\r\n                                ? w - label.textMetrics.width + xOffset\r\n                                : x\r\n                    }\r\n                    label.x = x\r\n                }\r\n                // render labels\r\n                for (let i = 0, n = labels.length; i < n; i ++) {\r\n                    const label = labels[i]\r\n                    if (!opts.yAxisLabelDisplayZero && label.i === 0) {\r\n                        continue\r\n                    }\r\n                    ctx.fillRect(o[0] + markOffset, label.gridY, markSize, px)\r\n                    ctx.fillText(\r\n                        label.text,\r\n                        label.x,\r\n                        label.y\r\n                    )\r\n                }\r\n            }\r\n        }\r\n\r\n        // draw hints\r\n        if (opts.hints) {\r\n            const { createHints, displaceHints, renderHints } = opts.hints\r\n            let hints = createHints(\r\n                ctx,\r\n                this.focusPoint,\r\n                { width: w, height: h, pixelRatio: px },\r\n                datasets,\r\n                opts,\r\n                {\r\n                    transform,\r\n                    isIntersects,\r\n                    // measureText: text => ctx.measureText(text)\r\n                }\r\n            )\r\n            hints = displaceHints(hints)\r\n            renderHints(hints)\r\n        }\r\n\r\n        // unclip\r\n        if (clipPath) {\r\n            ctx.restore()\r\n        }\r\n\r\n        // callback\r\n        if (opts.afterRepaint) {\r\n            opts.afterRepaint()\r\n        }\r\n    }\r\n}\r\n\r\nexport default Chart\r\n", "const buildTree = (source, s, e, T) => {\r\n    const isLeaf = (e - s) <= T\r\n    let [ minX, minY ] = source.at(s)\r\n    let [ maxX, maxY ] = source.at(e)\r\n    let left\r\n    let right\r\n    if (isLeaf) {\r\n        for (let i = s; i <= e; i ++) {\r\n            const y = source.at(i)[1]\r\n            if (minY > y) {\r\n                minY = y\r\n            }\r\n            if (maxY < y) {\r\n                maxY = y\r\n            }\r\n        }\r\n    } else {\r\n        const h = Math.floor((e - s) / 2)\r\n        const m = s + h\r\n        left = buildTree(source, s, m, T)\r\n        right = buildTree(source, m, e, T)\r\n        minY = Math.min(left.minY, right.minY)\r\n        maxY = Math.max(left.maxY, right.maxY)\r\n    }\r\n    return {\r\n        s,\r\n        e,\r\n        minX,\r\n        minY,\r\n        maxX,\r\n        maxY,\r\n        left,\r\n        right\r\n    }\r\n}\r\n\r\nclass Dataset {\r\n\r\n    constructor(legend = '', options = {}) { // TODO use mergeOptions\r\n        if (!('groupId' in options)) {\r\n            options.groupId = null\r\n        }\r\n        if (!('lineColor' in options)) {\r\n            const f = () => Math.round(Math.random() * 256)\r\n            options.lineColor = `rgb(${f()},${f()},${f()})`\r\n        }\r\n        if (!('isStepped' in options)) {\r\n            options.isStepped = false\r\n        }\r\n        if (!('lineWidth' in options)) {\r\n            options.lineWidth = 1\r\n        }\r\n        if (!('lineDash' in options)) {\r\n            options.lineDash = []\r\n        }\r\n        if (!('pointRadius' in options)) {\r\n            options.pointRadius = 0\r\n        }\r\n        this.legend = legend\r\n        this.options = options\r\n    }\r\n\r\n    compile(source, T) {\r\n        this.source = source\r\n        this.rebuild(T)\r\n    }\r\n\r\n    rebuild(T = 100) {\r\n        const source = this.source\r\n        const length = source.length\r\n        this.tree = length > 0 ? buildTree(source, 0, length - 1, T) : null\r\n    }\r\n\r\n    getExtrems(initialMinX = null, initialMinY = null, initialMaxX = null, initialMaxY = null) { // TODO use tree\r\n        let minX = initialMinX\r\n        let maxX = initialMaxX\r\n        let minY = initialMinY\r\n        let maxY = initialMaxY\r\n        const { source } = this\r\n        for (let i = 0, n = source.length; i < n; i ++) {\r\n            const [ x, y ] = source.at(i)\r\n            if (minX === null || minX > x) {\r\n                minX = x\r\n            }\r\n            if (maxX === null || maxX < x) {\r\n                maxX = x\r\n            }\r\n            if (minY === null || minY > y) {\r\n                minY = y\r\n            }\r\n            if (maxY === null || maxY < y) {\r\n                maxY = y\r\n            }\r\n        }\r\n        return { minX, minY, maxX, maxY }\r\n    }\r\n\r\n    getBoundingRect() { // DEPRECATED\r\n        const { minX, minY, maxX, maxY } = this.getExtrems()\r\n        const rect = new DOMRect(minX, minY, maxX - minX, maxY - minY)\r\n        rect.minX = minX\r\n        rect.minY = minY\r\n        rect.maxX = maxX\r\n        rect.maxY = maxY\r\n        return rect\r\n    }\r\n}\r\n\r\nexport default Dataset\r\n"],
  "mappings": "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",
  "names": ["isZero", "x", "eps", "vec2", "y", "vec2clone", "p", "vec2copy", "r", "p", "vec2add", "p1", "p2", "vec2sub", "vec2mul", "vec2div", "vec2lerp", "s", "vec2neglerp", "vec2muladd", "r", "p", "s", "t", "vec2subdiv", "findLess", "getter", "low", "high", "key", "result", "mid", "midVal", "dropEvent", "evt", "EVT_NAME_POINTERDOWN", "EVT_NAME_POINTERMOVE", "EVT_NAME_POINTERUP", "EVT_NAME_POINTERZOOM", "defaultOptions", "TouchGestures", "element", "options", "opts", "fireEvent", "name", "detail", "pointerdown", "originalEvent", "x", "y", "pointerup", "pointerzoom", "deltaScale", "pointermove", "dx", "dy", "touchId", "secondTouchId", "touchPoint", "secondTouchPoint", "wheelDirection", "wheelStep", "result", "clientRect", "touch", "res", "touches", "secondTouch", "touchNewPoint", "secondTouchNewPoint", "dxNew", "dyNew", "previousLength", "length", "point", "pointNew", "TouchGestures_default", "isObject", "isArray", "a", "mergeObjects", "b", "result", "k", "v", "defaultHintsSettings", "dataset", "defaultSettings", "createHints", "ctx", "focusPoint", "viewport", "datasets", "opts", "helpers", "fontFamily", "fontSize", "hintText", "passedSettings", "settings", "mergeObjects", "focus", "borderRadius", "paddingOrigin", "markOrigin", "splitterOrigin", "innerRadius", "outerRadius", "p", "vec2", "transform", "list", "pixelRatio", "mark", "padding", "splitter", "fs", "i", "n", "contents", "fullWidth", "fullHeight", "correction", "j", "m", "metrics", "width", "ascent", "descent", "offsetX", "offsetY", "displaceHints", "hints", "height", "isIntersects", "splitterHeight", "listNext", "a", "b", "isChanged", "numIterations", "delta", "k", "renderHints", "font", "color", "shadow", "axes", "backgroundColor", "item", "left", "top", "right", "bottom", "lineWidth", "focusPoints", "y", "blur", "xOrigin", "yOrigin", "lineColor", "x", "border", "background", "text", "texts", "marks", "offsetLeft", "offsetTop", "l", "defaultLegendsSettings", "defaultSettings", "createLegends", "ctx", "viewport", "datasets", "opts", "legendText", "passedSettings", "settings", "mergeObjects", "itemPaddingOrigin", "paddingOrigin", "markOrigin", "fontFamily", "fontSize", "list", "maxWidth", "correction", "pixelRatio", "fs", "mark", "padding", "itemPadding", "legends", "groups", "dataset", "i", "groupId", "a", "b", "n", "content", "metrics", "width", "ascent", "descent", "availWidth", "numColumns", "maxColumnsUsed", "maxRowsUsed", "rowHeight", "item", "columnIndex", "rowIndex", "legendsHeight", "shiftX", "shiftY", "renderLegends", "area", "font", "color", "backgroundColor", "left", "top", "right", "bottom", "text", "lineColor", "offsetLeft", "offsetTop", "innerRadius", "outerRadius", "x", "y", "isIntersects", "r1", "r2", "isNodesIntersects", "nodes", "n", "j", "defaultOptions", "x", "y", "defaultHintsSettings", "dataset", "opts", "pointSource", "createHints", "displaceHints", "renderHints", "defaultLegendsSettings", "createLegends", "renderLegends", "Chart", "elCanvas", "options", "mergeObjects", "vec2", "mouseState", "pointFromMouseEvent", "evt", "left", "right", "top", "bottom", "TouchGestures_default", "isInsideCanvas", "vec2sub", "vec2copy", "delta", "r", "vec2subdiv", "vec2mul", "vec2div", "deltaScale", "doScaleX", "doScaleY", "p", "source", "length", "i0", "findLess", "i", "i1", "p1", "p2", "t", "vec2lerp", "evtName", "vec2clone", "boundingRect", "keepAspectRatio", "w", "h", "bRect", "px", "canvasStep", "axesStep", "dw", "dh", "initialMinX", "initialMinY", "initialMaxX", "initialMaxY", "minX", "maxX", "minY", "maxY", "extrems", "rect", "vec2add", "pt", "o", "s", "vec2neglerp", "vec2muladd", "ctx", "datasets", "su", "u", "gridScale", "subdivisions", "stx", "sty", "transform", "clipPath", "legends", "tree", "p0", "renderNode", "node", "x0", "x1", "renderNodeStepped", "PI2", "renderNodePoints", "fs", "xOffset", "yOffset", "markOffset", "markSize", "spacing", "halfSpacing", "labels", "labelsOutOfTopBound", "labelsOutOfBottomBound", "v", "text", "textMetrics", "label", "joiningStep", "srcLabels", "isZero", "maxWidth", "labelsOutOfLeftBound", "labelsOutOfRightBound", "hints", "Chart_default", "buildTree", "source", "s", "e", "T", "isLeaf", "minX", "minY", "maxX", "maxY", "left", "right", "i", "y", "h", "Dataset", "legend", "options", "f", "length", "initialMinX", "initialMinY", "initialMaxX", "initialMaxY", "n", "x", "rect", "Dataset_default"]
}
