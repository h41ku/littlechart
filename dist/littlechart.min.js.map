{
  "version": 3,
  "sources": ["../src/vec2.js", "../node_modules/binary-search-algorithms/sync/findLess.js", "../node_modules/touchgestures/src/index.js", "../src/mergeObjects.js", "../src/Hints.js", "../src/Legends.js", "../src/Chart.js", "../src/Dataset.js"],
  "sourcesContent": ["function clamp(min, max, x) {\n    return Math.max(min, Math.min(x, max))\n}\n\nfunction isZero(x, eps = 0.001) {\n    return Math.abs(x) < eps\n}\n\nfunction vec2(x = 0, y = 0) {\n    return [ x, y ]\n}\n\nfunction vec2clone(p) {\n    return vec2(p[0], p[1])\n}\n\nfunction vec2set(r, x, y) {\n    r[0] = x\n    r[1] = y\n    return r\n}\n\nfunction vec2copy(r, p) {\n    r[0] = p[0]\n    r[1] = p[1]\n    return r\n}\n\nfunction vec2add(r, p1, p2) {\n    r[0] = p1[0] + p2[0]\n    r[1] = p1[1] + p2[1]\n    return r\n}\n\nfunction vec2sub(r, p1, p2) {\n    r[0] = p1[0] - p2[0]\n    r[1] = p1[1] - p2[1]\n    return r\n}\n\nfunction vec2mul(r, p1, p2) {\n    r[0] = p1[0] * p2[0]\n    r[1] = p1[1] * p2[1]\n    return r\n}\n\nfunction vec2div(r, p1, p2) {\n    r[0] = p1[0] / p2[0]\n    r[1] = p1[1] / p2[1]\n    return r\n}\n\nfunction vec2lerp(r, p1, p2, s) {\n    r[0] = p1[0] + s[0] * (p2[0] - p1[0])\n    r[1] = p1[1] + s[1] * (p2[1] - p1[1])\n    return r\n}\n\nfunction vec2neglerp(r, p1, p2, s) {\n    r[0] = p1[0] - s[0] * (p2[0] - p1[0])\n    r[1] = p1[1] - s[1] * (p2[1] - p1[1])\n    return r\n}\n\nfunction vec2clamp(r, min, max, p) {\n    r[0] = clamp(min, max, p[0])\n    r[1] = clamp(min, max, p[1])\n    return r\n}\n\nfunction vec2muladd(r, p, s, t) {\n    r[0] = p[0] * s[0] + t[0]\n    r[1] = p[1] * s[1] + t[1]\n    return r\n}\n\nfunction vec2subdiv(r, p, s, t) {\n    r[0] = (p[0] - t[0]) / s[0]\n    r[1] = (p[1] - t[1]) / s[1]\n    return r\n}\n\nexport {\n\n    clamp,\n    isZero,\n    vec2,\n    vec2clone,\n    vec2set,\n    vec2copy,\n    vec2add,\n    vec2sub,\n    vec2mul,\n    vec2div,\n    vec2lerp,\n    vec2neglerp,\n    vec2clamp,\n    vec2muladd,\n    vec2subdiv\n}", "export default (compareWithSync, low, high) => {\n    let result = -1\n    while (low <= high) {\n        const mid = low + Math.floor((high - low + 1) / 2)\n        const cmp = compareWithSync(mid)\n        if (cmp < 0) {\n            result = mid\n            low = mid + 1\n        } else if (cmp > 0) {\n            high = mid - 1\n        } else if (cmp === 0) {\n            high = mid - 1\n        }\n    }\n    return result\n}\n", "const dropEvent = evt => {\n    evt.preventDefault()\n    evt.stopPropagation()\n}\n\nexport const POINTER_DOWN = 'touchgestures:pointerdown'\nexport const POINTER_MOVE = 'touchgestures:pointermove'\nexport const POINTER_UP = 'touchgestures:pointerup'\nexport const POINTER_ZOOM = 'touchgestures:pointerzoom'\n\nconst defaultOptions = {\n    listenerElement: null,\n    invertMouseWheel: false,\n    mouseWheelStep: 0.1\n}\n\nexport default class TouchGestures {\n\n    constructor(element, options = {}) {\n\n        const opts = { ...defaultOptions, ...options }\n\n        this.element = element\n        this.listenerElement = opts.listenerElement !== null ? opts.listenerElement : element\n\n        const fireEvent = (name, detail) => this.element.dispatchEvent(new CustomEvent(name, { detail }))\n\n        const pointerdown = (originalEvent, x, y) => fireEvent(POINTER_DOWN, { originalEvent, clientX: x, clientY: y })\n        const pointerup = (originalEvent, x, y) => fireEvent(POINTER_UP, { originalEvent, clientX: x, clientY: y })\n        const pointerzoom = (originalEvent, x, y, deltaScale) => fireEvent(POINTER_ZOOM, { originalEvent, clientX: x, clientY: y, deltaScale })\n        const pointermove = (originalEvent, x, y, dx, dy) => fireEvent(POINTER_MOVE, { originalEvent, clientX: x, clientY: y, movementX: dx, movementY: dy })\n\n        let touchId = null\n        let secondTouchId = null\n        const touchPoint = { x: 0, y: 0 }\n        const secondTouchPoint = { x: 0, y: 0 }\n        const wheelDirection = opts.invertMouseWheel ? -1 : 1\n        const wheelStep = opts.mouseWheelStep\n\n        this.listeners = {\n\n            touchstart: evt => {\n                const clientRect = evt.target.getBoundingClientRect()\n                if (touchId !== null) {\n                    const touch = evt.changedTouches[0]\n                    if (touch.identifier !== touchId) {\n                        secondTouchId = touch.identifier\n                        secondTouchPoint.x = touch.clientX - clientRect.left\n                        secondTouchPoint.y = touch.clientY - clientRect.top\n                        pointerup(evt, touchPoint.x, touchPoint.y)\n                        pointerdown(\n                            evt,\n                            touchPoint.x + (secondTouchPoint.x - touchPoint.x) / 2,\n                            touchPoint.y + (secondTouchPoint.y - touchPoint.y) / 2\n                        )\n                    }\n                } else {\n                    const touch = evt.changedTouches[0]\n                    touchId = touch.identifier\n                    touchPoint.x = touch.clientX - clientRect.left\n                    touchPoint.y = touch.clientY - clientRect.top\n                    pointerdown(evt, touchPoint.x, touchPoint.y)\n                }\n            },\n\n            touchend: evt => {\n                let touches = Array.from(evt.changedTouches)\n                if (touchId !== null && secondTouchId !== null) {\n                    const touch = touches.find(touch => touchId === touch.identifier)\n                    const secondTouch = touches.find(touch => secondTouchId === touch.identifier)\n                    pointerup(\n                        evt,\n                        touchPoint.x + (secondTouchPoint.x - touchPoint.x) / 2,\n                        touchPoint.y + (secondTouchPoint.y - touchPoint.y) / 2\n                    )\n                    if (touch && secondTouch) {\n                        touchId = null\n                        secondTouchId = null\n                    } else if (touch && !secondTouch) {\n                        touchId = secondTouchId\n                        touchPoint.x = secondTouchPoint.x\n                        touchPoint.y = secondTouchPoint.y\n                        secondTouchId = null\n                    } else if (!touch && secondTouch) {\n                        secondTouchId = null\n                    }\n                    if (touchId !== null) {\n                        pointerdown(evt, touchPoint.x, touchPoint.y)\n                    }\n                } else if (touchId !== null) {\n                    const touch = touches.find(touch => touchId === touch.identifier)\n                    if (touch) {\n                        touchId = null\n                        pointerup(evt, touchPoint.x, touchPoint.y)\n                    }\n                }\n            },\n\n            touchmove: evt => {\n                const clientRect = evt.target.getBoundingClientRect()\n                if (touchId !== null && secondTouchId !== null) {\n                    const touchNewPoint = { x: touchPoint.x, y: touchPoint.y }\n                    const secondTouchNewPoint = { x: secondTouchPoint.x, y: secondTouchPoint.y }\n                    const touch = Array.from(evt.changedTouches).find(touch => touchId === touch.identifier)\n                    const secondTouch = Array.from(evt.changedTouches).find(touch => secondTouchId === touch.identifier)\n                    if (touch) {\n                        touchNewPoint.x = touch.clientX - clientRect.left\n                        touchNewPoint.y = touch.clientY - clientRect.top\n                    }\n                    if (secondTouch) {\n                        secondTouchNewPoint.x = secondTouch.clientX - clientRect.left\n                        secondTouchNewPoint.y = secondTouch.clientY - clientRect.top\n                    }\n                    const dx = secondTouchPoint.x - touchPoint.x\n                    const dy = secondTouchPoint.y - touchPoint.y\n                    const dxNew = secondTouchNewPoint.x - touchNewPoint.x\n                    const dyNew = secondTouchNewPoint.y - touchNewPoint.y\n                    const previousLength = Math.hypot(dx, dy)\n                    const length = Math.hypot(dxNew, dyNew)\n                    const deltaScale = (1 - (previousLength / length))\n                    const point = {\n                        x: touchPoint.x + dx / 2,\n                        y: touchPoint.y + dy / 2\n                    }\n                    const pointNew = {\n                        x: touchNewPoint.x + dxNew / 2,\n                        y: touchNewPoint.y + dyNew / 2\n                    }\n                    pointermove(\n                        evt,\n                        pointNew.x,\n                        pointNew.y,\n                        pointNew.x - point.x,\n                        pointNew.y - point.y\n                    )\n                    pointerup(evt, pointNew.x, pointNew.y)\n                    pointerzoom(evt, pointNew.x, pointNew.y, deltaScale)\n                    pointerdown(evt, pointNew.x, pointNew.y)\n                    touchPoint.x = touchNewPoint.x\n                    touchPoint.y = touchNewPoint.y\n                    secondTouchPoint.x = secondTouchNewPoint.x\n                    secondTouchPoint.y = secondTouchNewPoint.y\n                } else if (touchId !== null) {\n                    const touchNewPoint = { x: touchPoint.x, y: touchPoint.y }\n                    const touch = Array.from(evt.changedTouches)\n                        .find(touch => touchId === touch.identifier)\n                    if (!touch) {\n                        return\n                    }\n                    touchNewPoint.x = touch.clientX - clientRect.left\n                    touchNewPoint.y = touch.clientY - clientRect.top\n                    pointermove(\n                        evt,\n                        touchNewPoint.x,\n                        touchNewPoint.y,\n                        touchNewPoint.x - touchPoint.x,\n                        touchNewPoint.y - touchPoint.y\n                    )\n                    touchPoint.x = touchNewPoint.x\n                    touchPoint.y = touchNewPoint.y\n                }\n            },\n\n            mousedown: evt => {\n                touchPoint.x = evt.clientX\n                touchPoint.y = evt.clientY\n                pointerdown(evt, touchPoint.x, touchPoint.y)\n            },\n\n            mouseup: evt => {\n                touchPoint.x = evt.clientX\n                touchPoint.y = evt.clientY\n                pointerup(evt, touchPoint.x, touchPoint.y)\n            },\n\n            mousemove: evt => {\n                const touchNewPoint = { x: evt.clientX, y: evt.clientY }\n                pointermove(evt,\n                    touchNewPoint.x,\n                    touchNewPoint.y,\n                    touchNewPoint.x - touchPoint.x,\n                    touchNewPoint.y - touchPoint.y\n                )\n                touchPoint.x = touchNewPoint.x\n                touchPoint.y = touchNewPoint.y\n            },\n\n            wheel: evt => {\n                const deltaScale = wheelStep * (evt.deltaY > 0 ? 1 : -1) * wheelDirection\n                pointerzoom(evt, evt.clientX, evt.clientY, deltaScale)\n            }\n\n        }\n    }\n\n    enableNativeGestures() {\n\n        document.removeEventListener('gesturestart', dropEvent)\n        document.removeEventListener('gesturechange', dropEvent)\n        document.removeEventListener('gestureend', dropEvent)\n    }\n\n    disableNativeGestures() {\n\n        document.addEventListener('gesturestart', dropEvent)\n        document.addEventListener('gesturechange', dropEvent)\n        document.addEventListener('gestureend', dropEvent)\n    }\n\n    enableTouchGestures() {\n\n        this.listenerElement.addEventListener('touchstart', this.listeners.touchstart)\n        document.addEventListener('touchend', this.listeners.touchend)\n        document.addEventListener('touchmove', this.listeners.touchmove)\n    }\n\n    disableTouchGestures() {\n\n        this.listenerElement.removeEventListener('touchstart', this.listeners.touchstart)\n        document.removeEventListener('touchend', this.listeners.touchend)\n        document.removeEventListener('touchmove', this.listeners.touchmove)\n    }\n\n    enableMouseGestures() {\n\n        this.listenerElement.addEventListener('mousedown', this.listeners.mousedown)\n        document.addEventListener('mouseup', this.listeners.mouseup)\n        document.addEventListener('mousemove', this.listeners.mousemove)\n        this.listenerElement.addEventListener('wheel', this.listeners.wheel)\n        document.addEventListener('mouseleave', this.listeners.mouseup) // TODO test it\n    }\n\n    disableMouseGestures() {\n\n        this.listenerElement.removeEventListener('mousedown', this.listeners.mousedown)\n        document.removeEventListener('mouseup', this.listeners.mouseup)\n        document.removeEventListener('mousemove', this.listeners.mousemove)\n        document.removeEventListener('wheel', this.listeners.wheel)\n        document.removeEventListener('mouseleave', this.listeners.mouseup) // TODO test it\n    }\n}\n", "const isObject = o => typeof o === 'object'\nconst isArray = a => a instanceof Array\n\nexport default function mergeObjects(a, b) {\n    const result = { ...a, ...b }\n    Object.entries(b).forEach(({ 0: k, 1: v }) => {\n        if (k in a && isObject(v) && !isArray(v) && v !== null) {\n            result[k] = mergeObjects(a[k], v)\n        }\n    })\n    return result\n}\n", "import { vec2 } from './vec2.js'\nimport mergeObjects from './mergeObjects.js'\n\nfunction defaultHintsSettings() {\n    return {\n        focus: {\n            points: {\n                innerRadius: dataset => dataset.options.lineWidth * 2,\n                outerRadius: dataset => dataset.options.lineWidth * 2 + dataset.options.lineWidth,\n            },\n            axes: {\n                x: {\n                    color: 'rgba(0,0,0,0.1)',\n                    lineWidth: 1\n                },\n                y: {\n                    color: 'rgba(0,0,0,0.1)',\n                    lineWidth: 1\n                }\n            }\n        },\n        color: {\n            border: 'rgba(0,0,0,0)',\n            background: '#000000',\n            text: '#ffffff',\n        },\n        shadow: {\n            offsetX: 0,\n            offsetY: 15,\n            blur: 5, // 20,\n            color: 'rgba(0,0,0,0.2)',\n        },\n        borderRadius: {\n            leftTop: 5,\n            rightTop: 5,\n            leftBottom: 5,\n            rightBottom: 5\n        },\n        viewportPadding: {\n            left: 15,\n            right: 15,\n            top: 15,\n            bottom: 15\n        },\n        padding: {\n            left: 25,\n            right: 10,\n            top: 5,\n            bottom: 5\n        },\n        mark: {\n            offsetLeft: 15,\n            offsetTop: 15,\n            innerRadius: 0,\n            outerRadius: 3\n        },\n        splitter: {\n            height: 5\n        },\n        unitInvisibleHints: true,\n        maxNumIterations: 20\n    }\n}\n\nconst defaultSettings = defaultHintsSettings()\n\nfunction createHints(ctx, focusPoint, viewport, datasets, opts, helpers) {\n    // settings\n    const { fontFamily, fontSize } = opts\n    const { hintText, settings: passedSettings } = opts.hints\n    const settings = mergeObjects(defaultSettings, passedSettings)\n    const {\n        focus,\n        borderRadius,\n        padding: paddingOrigin,\n        mark: markOrigin,\n        splitter: splitterOrigin\n    } = settings\n    const { innerRadius, outerRadius } = focus.points\n    // create hints\n    const p = vec2()\n    const { transform } = helpers\n    const list = []\n    const pixelRatio = viewport.pixelRatio\n    const mark = { ...markOrigin }\n    mark.offsetLeft *= pixelRatio\n    mark.offsetTop *= pixelRatio\n    mark.innerRadius *= pixelRatio\n    mark.outerRadius *= pixelRatio\n    const padding = { ...paddingOrigin }\n    padding.left *= pixelRatio\n    padding.top *= pixelRatio\n    padding.right *= pixelRatio\n    padding.bottom *= pixelRatio\n    const splitter = { ...splitterOrigin }\n    splitter.height *= pixelRatio\n    const fs = fontSize * pixelRatio\n    ctx.font = `${fs}px/1 ${fontFamily}`\n    for (let i = 0, n = datasets.length; i < n; i ++) {\n        const dataset = datasets[i]\n        const focusPoint = dataset.focusPoint\n        if (focusPoint) {\n            transform(p, focusPoint)\n            const contents = hintText(focusPoint[0], focusPoint[1], dataset, opts, focusPoint.source).split('\\n')\n            let fullWidth = 0\n            let fullHeight = 0\n            let correction = 0\n            for (let j = 0, m = contents.length; j < m; j ++) {\n                const metrics = ctx.measureText(contents[j])\n                const width = metrics.width\n                if (fullWidth < width)\n                    fullWidth = width\n                fullHeight += fs\n                const ascent = -Math.abs(metrics.actualBoundingBoxAscent)\n                const descent = Math.abs(metrics.actualBoundingBoxDescent)\n                correction = fs - (descent - ascent) // TODO\n            }\n            fullHeight += padding.top + padding.bottom + correction // TODO\n            fullWidth += padding.left + padding.right\n            const offsetX = p[0] + 20 // - fullWidth / 2 // TODO use func\n            const offsetY = p[1] - fullHeight / 2 // TODO use func\n            list.push({\n                focusPoints: [{\n                    x: p[0],\n                    y: p[1],\n                    innerRadius: innerRadius(dataset) * pixelRatio,\n                    outerRadius: outerRadius(dataset) * pixelRatio,\n                    dataset\n                }],\n                left: offsetX,\n                top: offsetY,\n                right: offsetX + fullWidth,\n                bottom: offsetY + fullHeight,\n                correction, // TODO\n                texts: [{\n                    offsetLeft: padding.left,\n                    offsetTop: padding.top,\n                    contents\n                }],\n                padding,\n                marks: [{\n                    ...mark,\n                    dataset\n                }]\n            })\n        }\n    }\n    transform(p, focusPoint)\n    return {\n        ctx,\n        focus: {\n            origin: focusPoint,\n            x: p[0],\n            y: p[1]\n        },\n        viewport: {\n            ...viewport,\n            backgroundColor: opts.backgroundColor\n        },\n        settings: mergeObjects(settings, {\n            font: {\n                family: fontFamily,\n                size: fs\n            },\n            borderRadius: borderRadius ? [\n                Math.round(borderRadius.leftTop * pixelRatio),\n                Math.round(borderRadius.rightTop * pixelRatio),\n                Math.round(borderRadius.rightBottom * pixelRatio),\n                Math.round(borderRadius.leftBottom * pixelRatio)\n            ] : null,\n            splitter\n        }),\n        helpers,\n        list\n    }\n}\n\nconst displaceHints = hints => {\n    const { list, settings, viewport: { width, height, pixelRatio }, helpers: { isIntersects } } = hints\n    const { viewportPadding: padding, splitter: { height: splitterHeight } } = settings\n    const viewport = {\n        left: padding.left * pixelRatio,\n        right: width - padding.right * pixelRatio,\n        top: padding.top * pixelRatio,\n        bottom: height - padding.bottom * pixelRatio\n    }\n    let listNext = [ ...list ].sort((a, b) => a.focusPoints[a.focusPoints.length - 1].y - b.focusPoints[0].y)\n    let isChanged = true\n    let numIterations = 0\n    while (isChanged) {\n        numIterations ++\n        isChanged = false\n        for (let i = 0, n = listNext.length; i < n; i ++) {\n            const a = listNext[i]\n            if (a === null) {\n                continue\n            }\n            for (let j = i + 1; j < n; j ++) {\n                const b = listNext[j]\n                if (b === null) {\n                    continue\n                }\n                if (isIntersects(a, b)) {\n                    //const delta = a.bottom - a.top - a.padding.bottom - b.padding.top - b.padding.bottom //+ splitterHeight\n                    const delta = a.bottom - a.top - a.padding.bottom - b.padding.top - a.correction + splitterHeight\n                    for (let k = 0, m = b.texts.length; k < m; k ++) {\n                        b.texts[k].offsetTop += delta\n                    }\n                    for (let k = 0, m = b.marks.length; k < m; k ++) {\n                        b.marks[k].offsetTop += delta\n                    }\n                    a.right = Math.max(a.right, a.left + (b.right - b.left))\n                    a.bottom += (b.bottom - b.top - a.padding.bottom - b.padding.top - a.correction) + splitterHeight\n                    a.texts = a.texts.concat(b.texts)\n                    a.focusPoints = a.focusPoints.concat(b.focusPoints)\n                    a.marks = a.marks.concat(b.marks)\n                    listNext[j] = null\n                    isChanged = true\n                }\n            }\n            listNext[i] = a\n        }\n        if (!settings.unitInvisibleHints) {\n            for (let i = 0, n = listNext.length; i < n; i ++) {\n                const a = listNext[i]\n                if (a === null) {\n                    continue\n                }\n                if (a.right < viewport.left\n                    || a.left > viewport.right\n                    || a.bottom < viewport.top\n                    || a.top > viewport.bottom)\n                {\n                    listNext[i] = null\n                    isChanged = true\n                }\n            }\n        }\n        listNext = listNext.filter(a => a)\n        for (let i = 0, n = listNext.length; i < n; i ++) {\n            const a = listNext[i]\n            if (a.left < viewport.left) {\n                const delta = (viewport.left - a.left)\n                a.left += delta\n                a.right += delta\n                isChanged = true\n            } else if (a.right > viewport.right) {\n                const delta = (a.right - viewport.right)\n                a.left -= delta\n                a.right -= delta\n                isChanged = true\n            }\n            if (a.top < viewport.top) {\n                const delta = (viewport.top - a.top)\n                a.top += delta\n                a.bottom += delta\n                isChanged = true\n            } else if (a.bottom > viewport.bottom) {\n                const delta = (a.bottom - viewport.bottom)\n                a.top -= delta\n                a.bottom -= delta\n                isChanged = true\n            }\n        }\n        if (listNext.length <= 1 || numIterations >= settings.maxNumIterations) {\n            break\n        }\n    }\n    return { ...hints, list: listNext }\n}\n\nconst renderHints = hints => {\n    // settings\n    const {\n        ctx,\n        list,\n        settings: {\n            font,\n            color,\n            shadow,\n            borderRadius,\n            focus: { axes },\n        },\n        viewport: { width, height, pixelRatio, backgroundColor }\n    } = hints\n    // round\n    for (let i = 0, n = list.length; i < n; i ++) {\n        const item = list[i]\n        const { left, top, right, bottom } = item\n        item.rect = {\n            left: Math.round(left),\n            top: Math.round(top),\n            width: Math.round(right - left),\n            height: Math.round(bottom - top),\n        }\n    }\n    // draw focus axes\n    if (axes.y) {\n        const { color, lineWidth } = axes.y\n        ctx.fillStyle = color\n        for (let i = 0, n = list.length; i < n; i ++) {\n            const { focusPoints } = list[i]\n            for (let j = 0, m = focusPoints.length; j < m; j ++) {\n                const { y } = focusPoints[j]\n                ctx.fillRect(0, y, width, Math.round(lineWidth * pixelRatio))\n            }\n        }\n    }\n    if (axes.x) {\n        const { color, lineWidth } = axes.x\n        ctx.fillStyle = color\n        ctx.fillRect(hints.focus.x, 0, Math.round(lineWidth * pixelRatio), height)\n    }\n    // draw shadows\n    if (shadow) {\n        const { offsetX, offsetY, blur, color } = shadow\n        ctx.fillStyle = 'rgb(255,255,255)'\n        ctx.shadowColor = color\n        ctx.shadowOffsetX = offsetX\n        ctx.shadowOffsetY = offsetY\n        ctx.shadowBlur = blur\n        for (let i = 0, n = list.length; i < n; i ++) {\n            const { left, top, width, height } = list[i].rect\n            if (borderRadius) {\n                ctx.beginPath()\n                ctx.roundRect(\n                    left, top, width, height,\n                    borderRadius\n                )\n                ctx.fill()\n            } else {\n                ctx.fillRect(\n                    left, top, width, height\n                )\n            }\n        }\n        ctx.shadowColor = 'transparent'\n    }\n    // draw focus points\n    for (let i = 0, n = list.length; i < n; i ++) {\n        const { focusPoints } = list[i]\n        for (let j = 0, m = focusPoints.length; j < m; j ++) {\n            const { x: xOrigin, y: yOrigin, innerRadius, outerRadius, dataset: { options: { lineColor } } } = focusPoints[j]\n            const x = Math.round(xOrigin)\n            const y = Math.round(yOrigin)\n            ctx.fillStyle = lineColor.toString()\n            ctx.beginPath()\n            ctx.arc(x, y, Math.round(outerRadius), 0, 2 * Math.PI, false)\n            ctx.fill()\n            ctx.fillStyle = backgroundColor\n            ctx.beginPath()\n            ctx.arc(x, y, Math.round(innerRadius), 0, 2 * Math.PI, false)\n            ctx.fill()\n        }\n    }\n    // draw hints\n    const { border, background, text } = color\n    const fs = font.size\n    ctx.font = `${Math.round(fs)}px/1 ${font.family}`\n    for (let i = 0, n = list.length; i < n; i ++) {\n        const { rect: { left, top, width, height }, texts, marks } = list[i]\n        ctx.strokeStyle = border\n        ctx.fillStyle = background\n        if (borderRadius) {\n            ctx.beginPath()\n            ctx.roundRect(\n                left, top, width, height,\n                borderRadius\n            )\n            ctx.fill()\n            ctx.stroke()\n        } else {\n            ctx.fillRect(\n                left, top, width, height\n            )\n        }\n        ctx.fillStyle = text\n        for (let j = 0, m = texts.length; j < m; j ++) {\n            const { offsetLeft, offsetTop, contents } = texts[j]\n            const x = Math.round(offsetLeft + left)\n            let y = offsetTop + top\n            for (let k = 0, l = contents.length; k < l; k ++) {\n                ctx.fillText(\n                    contents[k],\n                    x,\n                    Math.round(y + fs)\n                )\n                y += fs\n            }\n        }\n        for (let j = 0, m = marks.length; j < m; j ++) {\n            const { offsetLeft, offsetTop, innerRadius, outerRadius, dataset: { options: { lineColor } } } = marks[j]\n            const x = Math.round(offsetLeft + left)\n            const y = Math.round(offsetTop + top)\n            ctx.fillStyle = lineColor.toString()\n            ctx.beginPath()\n            ctx.arc(x, y, outerRadius, 0, 2 * Math.PI, false)\n            ctx.fill()\n            ctx.fillStyle = backgroundColor\n            ctx.beginPath()\n            ctx.arc(x, y, innerRadius, 0, 2 * Math.PI, false)\n            ctx.fill()\n        }\n    }\n}\n\nexport {\n    defaultHintsSettings,\n    createHints,\n    displaceHints,\n    renderHints\n}\n", "import mergeObjects from './mergeObjects.js'\n\nfunction defaultLegendsSettings() {\n    return {\n        color: {\n            border: '#eeeeee',\n            background: '#ffffff',\n            text: '#000000',\n        },\n        padding: {\n            left: 5,\n            right: 5,\n            top: 5,\n            bottom: 5\n        },\n        itemPadding: {\n            left: 25,\n            right: 10,\n            top: 5,\n            bottom: 5\n        },\n        mark: {\n            offsetLeft: 15,\n            offsetTop: 15,\n            innerRadius: 0,\n            outerRadius: 3\n        }\n    }\n}\n\nconst defaultSettings = defaultLegendsSettings()\n\nfunction createLegends(ctx, viewport, datasets, opts) {\n    // settings\n    const { legendText, settings: passedSettings } = opts.legends\n    const settings = mergeObjects(defaultSettings, passedSettings)\n    const { itemPadding: itemPaddingOrigin, padding: paddingOrigin, mark: markOrigin } = settings\n    const { fontFamily, fontSize } = opts\n    // create legends\n    let list = []\n    let maxWidth = 0\n    let correction = 0\n    const pixelRatio = viewport.pixelRatio\n    const fs = fontSize * pixelRatio\n    const mark = { ...markOrigin }\n    mark.offsetLeft *= pixelRatio\n    mark.offsetTop *= pixelRatio\n    mark.innerRadius *= pixelRatio\n    mark.outerRadius *= pixelRatio\n    const padding = { ...paddingOrigin }\n    padding.left *= pixelRatio\n    padding.top *= pixelRatio\n    padding.right *= pixelRatio\n    padding.bottom *= pixelRatio\n    const itemPadding = { ...itemPaddingOrigin }\n    itemPadding.left *= pixelRatio\n    itemPadding.top *= pixelRatio\n    itemPadding.right *= pixelRatio\n    itemPadding.bottom *= pixelRatio\n    ctx.font = `${fs}px/1 ${fontFamily}`\n    const legends = [ ...Object.values(datasets.reduce((groups, dataset, i) => {\n        const groupId = dataset.options.groupId === null ? i : dataset.options.groupId\n        if (!(groupId in groups)) {\n            groups[groupId] = { dataset, i }\n        }\n        return groups\n    }, {})) ].sort((a, b) => a.i - b.i)\n    for (let i = 0, n = legends.length; i < n; i ++) {\n        const dataset = legends[i].dataset\n        const content = legendText(dataset, opts)\n        if (content) {\n            const metrics = ctx.measureText(content)\n            const width = metrics.width + itemPadding.left + itemPadding.right * pixelRatio\n            const ascent = -Math.abs(metrics.actualBoundingBoxAscent)\n            const descent = Math.abs(metrics.actualBoundingBoxDescent)\n            correction = Math.max(correction, fs - (descent - ascent)) // TODO\n            list.push({\n                text: {\n                    content,\n                    offsetLeft: itemPadding.left,\n                    offsetTop: itemPadding.top,\n                },\n                mark,\n                lineColor: dataset.options.lineColor,\n                width,\n                left: 0,\n                top: 0\n            })\n            if (maxWidth < width) {\n                maxWidth = width\n            }\n        }\n    }\n// list = [ ...list.map(item => ({ ...item })), ...list.map(item => ({ ...item })), ...list.map(item => ({ ...item })), ...list.map(item => ({ ...item })), ...list.map(item => ({ ...item })) ]\n    // displace legends\n    const availWidth = viewport.width - padding.left - padding.right\n    const numColumns = Math.floor(availWidth / maxWidth)\n// const numColumns = 2\n    let maxColumnsUsed = 0\n    let maxRowsUsed = 0\n    const rowHeight = fs + itemPadding.top + itemPadding.bottom + correction\n    for (let i = 0, n = list.length; i < n; i ++) {\n        const item = list[i]\n        const columnIndex = i % numColumns\n        const rowIndex = Math.floor(i / numColumns)\n        if (maxColumnsUsed < columnIndex) {\n            maxColumnsUsed = columnIndex\n        }\n        if (maxRowsUsed < rowIndex) {\n            maxRowsUsed = rowIndex\n        }\n        item.left = columnIndex * maxWidth\n        item.top = rowIndex * rowHeight\n    }\n    const legendsHeight = (maxRowsUsed + 1) * rowHeight + padding.top + padding.bottom\n    const shiftX = padding.left + (availWidth - (maxColumnsUsed + 1) * maxWidth) / 2\n    const shiftY = viewport.height - legendsHeight + padding.top\n    for (let i = 0, n = list.length; i < n; i ++) {\n        const item = list[i]\n        item.left += shiftX\n        item.top += shiftY\n    }\n    // clip viewport\n    viewport.clip(0, 0, viewport.width, viewport.height - legendsHeight)\n    // result\n    return {\n        ctx,\n        // rowHeight,\n        area: {\n            left: 0,\n            right: viewport.width,\n            top: viewport.height - legendsHeight,\n            bottom: viewport.height\n        },\n        viewport: {\n            ...viewport,\n            backgroundColor: opts.backgroundColor\n        },\n        settings: mergeObjects(settings, {\n            font: {\n                family: fontFamily,\n                size: fs\n            }\n        }),\n        list\n    }\n}\n\nfunction renderLegends(legends) {\n    // settings\n    const {\n        ctx,\n        // rowHeight,\n        area,\n        settings: { font, color },\n        viewport: { pixelRatio, backgroundColor },\n        list\n    } = legends\n    // variables\n    // draw area\n    if (color.background) {\n        const left = Math.round(area.left)\n        const top = Math.round(area.top)\n        const right = Math.round(area.right)\n        const bottom = Math.round(area.bottom)    \n        ctx.fillStyle = color.background\n        ctx.fillRect(\n            left,\n            top,\n            right - left,\n            bottom - top\n        )\n        if (color.border) {\n            ctx.fillStyle = color.border\n            ctx.fillRect(\n                left,\n                top,\n                right - left,\n                Math.round(1 * pixelRatio)\n            )\n        }\n    }\n    // draw legends\n    const fs = font.size\n    ctx.font = `${Math.round(fs)}px/1 ${font.family}`\n    for (let i = 0, n = list.length; i < n; i ++) {\n        let { left, top, text, mark, lineColor } = list[i]\n// ctx.fillStyle = 'rgba(255,0,0,0.1)'\n// ctx.fillRect(left,top,list[i].width,rowHeight)\n        ctx.fillStyle = color.text\n        {\n            let { offsetLeft, offsetTop, content } = text\n            offsetLeft += left\n            offsetTop += top\n            ctx.fillText(\n                content,\n                Math.round(offsetLeft),\n                Math.round(offsetTop + font.size)\n            )\n        }\n        {\n            const { offsetLeft, offsetTop, innerRadius, outerRadius } = mark\n            const x = Math.round(offsetLeft + left)\n            const y = Math.round(offsetTop + top)\n            ctx.fillStyle = lineColor.toString()\n            ctx.beginPath()\n            ctx.arc(x, y, Math.round(outerRadius), 0, 2 * Math.PI, false)\n            ctx.fill()\n            ctx.fillStyle = backgroundColor\n            ctx.beginPath()\n            ctx.arc(x, y, Math.round(innerRadius), 0, 2 * Math.PI, false)\n            ctx.fill()\n        }\n    }\n}\n\nexport {\n    defaultLegendsSettings,\n    createLegends,\n    renderLegends\n}\n", "import { isZero, vec2, vec2copy, vec2add, vec2sub, vec2mul, vec2div, vec2muladd, vec2neglerp, vec2subdiv, vec2lerp, vec2clone } from './vec2.js'\nimport { findLess } from 'binary-search-algorithms/sync'\nimport TouchGestures, * as touchGesturesEvents from 'touchgestures'\nimport { defaultHintsSettings, createHints, displaceHints, renderHints } from './Hints.js'\nimport { defaultLegendsSettings, createLegends, renderLegends } from './Legends.js'\nimport mergeObjects from './mergeObjects.js'\n\nfunction isIntersects(r1, r2) {\n    return r1.bottom > r2.top \n        && r1.right > r2.left \n        && r1.top < r2.bottom \n        && r1.left < r2.right\n}\n\nfunction isNodesIntersects(nodes) { // TODO optimize, test only half of array\n    const n = nodes.length \n    for (let i = 0; i < n; i ++) {\n        for (let j = 0; j < n; j ++) {\n            if (i === j) {\n                continue\n            }\n            if (isIntersects(nodes[i].boundingRect, nodes[j].boundingRect)) {\n                return true\n            }\n        }\n    }\n    return false\n}\n\nconst defaultOptions = {\n    xCanvasStep: 25,\n    yCanvasStep: 25,\n    xAxisStep: 1,\n    yAxisStep: 1,\n    xOffset: 0,\n    yOffset: 0,\n    xScale: 1,\n    yScale: 1,\n    xAxisSubdivisions: 10.0,\n    yAxisSubdivisions: 10.0,\n    lineWidth: 1,\n    pointSize: 0,\n    fontSize: 15,\n    fontFamily: 'monospace',\n    xAxisLabelXOffset: 0,\n    xAxisLabelYOffset: 0,\n    xAxisLabelDynamicPosition: true,\n    xAxisLabelSpacing: 15,\n    xAxisLabelFormat: x => x.toFixed(4),\n    xAxisLabelJoiningStep: 5.0,\n    xAxisLabelMarkOffset: -2,\n    xAxisLabelMarkSize: 4,\n    xAxisLabelDisplayZero: true,\n    xAxisLabelEnable: true,\n    yAxisLabelXOffset: 0,\n    yAxisLabelYOffset: 0,\n    yAxisLabelDynamicPosition: true,\n    yAxisLabelSpacing: 0,\n    yAxisLabelFormat: y => y.toFixed(4),\n    yAxisLabelJoiningStep: 5.0,\n    yAxisLabelMarkOffset: -2,\n    yAxisLabelMarkSize: 4,\n    yAxisLabelDisplayZero: true,\n    yAxisLabelEnable: true,\n    backgroundColor: '#ffffff',\n    gridColor: 'rgba(0,0,0,0.1)',\n    axesColor: 'rgba(0,0,0,0.5)',\n    userTranslateX: true,\n    userTranslateY: true,\n    userScaleX: true,\n    userScaleY: true,\n    canvasRatio: 1,\n    canvasPixelRatio: 1,\n    clearFrame: false,\n    hints: {\n        settings: defaultHintsSettings(),\n        hintText: (x, y, dataset, opts, pointSource) => `X: ${opts.xAxisLabelFormat(x)}\\nY: ${opts.yAxisLabelFormat(y)}`,\n        createHints,\n        displaceHints,\n        renderHints,\n    },\n    legends: {\n        settings: defaultLegendsSettings(),\n        legendText: (dataset, opts) => `${dataset.legend}`,\n        createLegends,\n        renderLegends,\n    },\n    cursorPointer: 'pointer',\n    cursorGrabbing: 'grabbing',\n    bindEventHandlers: true,\n    invertMouseWheel: false,\n    mouseWheelStep: 0.1,\n    afterRepaint: null\n}\n\nclass Chart {\n\n    constructor(elCanvas, options = {}) {\n\n        this.options = options = mergeObjects(defaultOptions, options)\n        this.elCanvas = elCanvas\n        this.ctx = elCanvas.getContext('2d')\n        this.scale = vec2(options.xScale, options.yScale)\n        this.translate = vec2(options.xOffset, options.yOffset)\n        this.focusPoint = vec2(0, 0)\n        this.datasets = []\n        this.currentXBounds = vec2()\n\n        elCanvas.style.cursor = options.cursorPointer\n\n        const mouseState = {\n            down: false,\n            pt0: vec2(0, 0),\n            pt: vec2(0, 0),\n            delta: vec2(0, 0)\n        }\n\n        const pointFromMouseEvent = (r, evt) => {\n            const { clientX: x, clientY: y } = evt\n            const { left, right, top, bottom } = elCanvas.getBoundingClientRect()\n            r[0] = (x - left) / options.canvasRatio\n            r[1] = (y - top) / options.canvasRatio\n            const isInsideCanvas = left <= x && x <= right\n                && top <= y && y <= bottom\n            return isInsideCanvas\n        }\n\n        this.isListening = false\n        this.listeners = { }\n        this.listeners[touchGesturesEvents.POINTER_DOWN] = evt => {\n            elCanvas.style.cursor = options.cursorGrabbing\n            evt.detail.originalEvent.preventDefault()\n            mouseState.down = true\n            pointFromMouseEvent(mouseState.pt0, evt.detail)\n        }\n        this.listeners[touchGesturesEvents.POINTER_UP] = evt => {\n            mouseState.down = false\n            elCanvas.style.cursor = options.cursorPointer\n        }\n        this.listeners[touchGesturesEvents.POINTER_MOVE] = evt => {\n            const isInsideCanvas = pointFromMouseEvent(mouseState.pt, evt.detail)\n            if (mouseState.down) {\n                vec2sub(mouseState.delta, mouseState.pt, mouseState.pt0)\n                vec2copy(mouseState.pt0, mouseState.pt)\n                const delta = vec2(\n                    options.userTranslateX ? mouseState.delta[0] : 0,\n                    options.userTranslateY ? mouseState.delta[1] : 0\n                )\n                this.move(delta)\n                this.repaint()\n            } else if (isInsideCanvas) {\n                const r = vec2()\n                vec2subdiv(r, mouseState.pt, vec2(options.xCanvasStep, options.yCanvasStep), this.translate)\n                r[1] = -r[1]\n                vec2mul(r, r, vec2(options.xAxisStep, options.yAxisStep))\n                vec2div(r, r, this.scale)\n                this.computeFocusPoints(r)\n                this.repaint()\n            }\n        }\n        this.listeners[touchGesturesEvents.POINTER_ZOOM] = evt => {\n            evt.detail.originalEvent.preventDefault()\n            const deltaScale = evt.detail.deltaScale\n            const doScaleX = options.userScaleX === true\n                || (typeof options.userScaleX === 'function' && options.userScaleX(evt))\n            const doScaleY = options.userScaleY === true\n                || (typeof options.userScaleY === 'function' && options.userScaleY(evt))\n            const delta = vec2(\n                doScaleX ? deltaScale : 0,\n                doScaleY ? deltaScale : 0\n            )\n            pointFromMouseEvent(mouseState.pt, evt.detail)\n            this.zoomAroundPoint(delta, mouseState.pt)\n            this.repaint()\n        }\n\n        this.touchGestures = new TouchGestures(elCanvas, {\n            invertMouseWheel: options.invertMouseWheel,\n            mouseWheelStep: options.mouseWheelStep\n        })\n\n        if (options.bindEventHandlers) {\n            this.bind()\n        }\n    }\n\n    computeFocusPoints(p) {\n\n        this.datasets.forEach(dataset => {\n            const { source } = dataset\n            const length = source.length\n            const i0 = findLess(i => source.at(i)[0] - p[0], 0, length - 1)\n            const i1 = i0 + 1\n            if (i0 >= 0 && i1 < length) {\n                const r = vec2()\n                const p1 = source.at(i0)\n                const p2 = source.at(i1)\n                const t = (p[0] - p1[0]) / (p2[0] - p1[0])\n                const s = vec2(t, dataset.options.isStepped ? 0 : t)\n                vec2lerp(r, p1, p2, s)\n                r.source = { i0, i1, s }\n                dataset.focusPoint = r\n            } else {\n                dataset.focusPoint = null\n            }\n        })\n        vec2copy(this.focusPoint, p)\n    }\n\n    bind() {\n\n        if (this.isListening) {\n            return\n        }\n\n        for (let evtName in this.listeners) {\n            this.elCanvas.addEventListener(evtName, this.listeners[evtName])\n        }\n        this.touchGestures.enableTouchGestures()\n        this.touchGestures.enableMouseGestures()\n        \n        this.isListening = true\n    }\n\n    unbind() {\n\n        if (!this.isListening) {\n            return\n        }\n\n        for (let evtName in this.listeners) {\n            this.elCanvas.removeEventListener(evtName, this.listeners[evtName])\n        }\n        this.touchGestures.disableTouchGestures()\n        this.touchGestures.disableMouseGestures()\n\n        this.isListening = false\n    }\n\n    getViewportXBounds() {\n\n        return vec2clone(this.currentXBounds)\n    }\n\n    fitView(boundingRect, keepAspectRatio = true) { \n\n        let w = this.elCanvas.width\n        let h = this.elCanvas.height\n\n        if (w <= 0 || h <= 0 || Math.abs(boundingRect.width) <= 0 || Math.abs(boundingRect.height) <= 0) {\n            return false\n        }\n\n        const opts = this.options\n\n        if (opts.legends) {\n            opts.legends.createLegends(\n                this.ctx,\n                {\n                    width: w,\n                    height: h,\n                    pixelRatio: opts.canvasRatio * opts.canvasPixelRatio,\n                    clip(left, top, right, bottom) {\n                        w = right - left\n                        h = bottom - top\n                        // TODO left, top is not used later\n                    }\n                },\n                this.datasets,\n                opts,\n                {\n                    isIntersects,\n                    // measureText: text => ctx.measureText(text)\n                }\n            )\n        }\n\n        const bRect = new DOMRect( // flip by Y\n            boundingRect.x,\n            -boundingRect.y - boundingRect.height,\n            boundingRect.width,\n            boundingRect.height\n        )\n\n        const px = opts.canvasRatio * opts.canvasPixelRatio\n        const canvasStep = vec2(opts.xCanvasStep, opts.yCanvasStep)\n        const axesStep = vec2(opts.xAxisStep, opts.yAxisStep)\n        w = (w / px / canvasStep[0]) * axesStep[0]\n        h = (h / px / canvasStep[1]) * axesStep[1]\n\n        this.scale[0] = w / bRect.width\n        this.scale[1] = h / bRect.height\n        if (keepAspectRatio) {\n            if (this.scale[1] > this.scale[0]) {\n                this.scale[1] = this.scale[0]\n            } else {\n                this.scale[0] = this.scale[1]\n            }\n        }\n\n        this.translate[0] = -(bRect.x / axesStep[0]) * canvasStep[0] * this.scale[0]\n        this.translate[1] = -(bRect.y / axesStep[1]) * canvasStep[1] * this.scale[1]\n        if (keepAspectRatio) {\n            const dw = (w / this.scale[0] - bRect.width) / 2\n            const dh = (h / this.scale[1] - bRect.height) / 2\n            this.translate[0] += dw * canvasStep[0] * this.scale[0] / axesStep[0]\n            this.translate[1] += dh * canvasStep[1] * this.scale[1] / axesStep[1]\n        }\n\n        return true\n    }\n\n    fitViewAuto(keepAspectRatio = true) {\n\n        this.fitView(this.getBoundingRect(null, 0, null, 0), keepAspectRatio)\n        this.repaint()\n    }\n\n    getExtremes(initialMinX = null, initialMinY = null, initialMaxX = null, initialMaxY = null) {\n\n        let minX = initialMinX\n        let maxX = initialMaxX\n        let minY = initialMinY\n        let maxY = initialMaxY\n\n        this.datasets.forEach(dataset => {\n            const extremes = dataset.getExtremes()\n            if (minX === null || minX > extremes.minX) {\n                minX = extremes.minX\n            }\n            if (maxX === null || maxX < extremes.maxX) {\n                maxX = extremes.maxX\n            }\n            if (minY === null || minY > extremes.minY) {\n                minY = extremes.minY\n            }\n            if (maxY === null || maxY < extremes.maxY) {\n                maxY = extremes.maxY\n            }\n        })\n\n        return { minX, minY, maxX, maxY }\n    }\n\n    getBoundingRect(initialMinX = null, initialMinY = null, initialMaxX = null, initialMaxY = null) { // DEPRECATED\n\n        const { minX, minY, maxX, maxY } = this.getExtremes()\n\n        const rect = new DOMRect(minX, minY, maxX - minX, maxY - minY)\n        rect.minX = minX\n        rect.minY = minY\n        rect.maxX = maxX\n        rect.maxY = maxY\n        \n        return rect\n    }\n\n    move(delta) {\n\n        vec2add(this.translate, this.translate, delta)\n    }\n\n    zoomAroundPoint(deltaScale, pt) {\n\n        const o = this.translate\n        const s = this.scale\n\n        vec2neglerp(o, o, pt, deltaScale)\n        vec2muladd(s, s, deltaScale, s)\n    }\n\n    repaint() {\n\n        let x\n        let y\n\n        const opts = this.options\n        const ctx = this.ctx\n        let w = this.elCanvas.width\n        let h = this.elCanvas.height\n        const s = this.scale\n        const datasets = this.datasets\n\n        if (w <= 0 || h <= 0 || s[0] === 0 || s[1] === 0) {\n            return\n        }\n\n        const px = opts.canvasRatio * opts.canvasPixelRatio\n        const canvasStep = vec2(opts.xCanvasStep * px, opts.yCanvasStep * px)\n\n        const o = vec2(this.translate[0] * px, this.translate[1] * px)\n        const su = vec2(canvasStep[0] * s[0], canvasStep[1] * s[1])\n        const u = vec2(opts.xAxisStep, opts.yAxisStep)\n        const gridScale = vec2(1, 1)\n        const subdivisions = vec2(opts.xAxisSubdivisions, opts.yAxisSubdivisions)\n        \n        while (su[0] > canvasStep[0] * subdivisions[0]) { // TODO optimize, remove loop\n            su[0] /= subdivisions[0]\n            gridScale[0] /= subdivisions[0]\n        }\n        while (su[1] > canvasStep[1] * subdivisions[1]) { // TODO optimize, remove loop\n            su[1] /= subdivisions[1]\n            gridScale[1] /= subdivisions[1]\n        }\n        while (su[0] < canvasStep[0]) { // TODO optimize, remove loop\n            su[0] *= subdivisions[0]\n            gridScale[0] *= subdivisions[0]\n        }\n        while (su[1] < canvasStep[1]) { // TODO optimize, remove loop\n            su[1] *= subdivisions[1]\n            gridScale[1] *= subdivisions[1]\n        }\n\n        const stx = o[0] - (Math.floor(o[0] / su[0]) + (o[0] > 0 ? 1 : 0)) * su[0]\n        const sty = o[1] - (Math.floor(o[1] / su[1]) + (o[1] > 0 ? 1 : 0)) * su[1]\n\n        const transform = (r, p) => {\n            vec2mul(r, p, canvasStep)\n            vec2div(r, r, u)\n            r[1] = -r[1]\n            vec2muladd(r, r, s, o)\n        }\n\n        // clear\n        if (opts.clearFrame) {\n            ctx.clearRect(0, 0, w, h)\n        }\n        ctx.fillStyle = opts.backgroundColor\n        ctx.fillRect(0, 0, w, h)\n\n        let clipPath = null\n\n        // draw legends\n        if (opts.legends) {\n            const { createLegends, renderLegends } = opts.legends\n            const legends = createLegends(\n                ctx,\n                {\n                    width: w,\n                    height: h,\n                    pixelRatio: px,\n                    clip(left, top, right, bottom) {\n                        w = right - left\n                        h = bottom - top\n                        clipPath = new Path2D()\n                        clipPath.rect(left, top, w, h)\n                    }\n                },\n                datasets,\n                opts,\n                {\n                    isIntersects,\n                    // measureText: text => ctx.measureText(text)\n                }\n            )\n            renderLegends(legends)\n        }\n\n        // clip\n        if (clipPath) {\n            ctx.save()\n            ctx.clip(clipPath)\n        }\n\n        // draw grid\n        ctx.fillStyle = opts.gridColor\n        for (let x = stx; x <= w; x += su[0]) {\n            ctx.fillRect(x, 0, 1 * px, h)\n        }\n        for (let y = sty; y <= h; y += su[1]) {\n            ctx.fillRect(0, y, w, 1 * px)\n        }\n\n        // draw axes\n        ctx.fillStyle = opts.axesColor\n        ctx.fillRect(o[0], 0, 1 * px, h)\n        ctx.fillRect(0, o[1], w, 1 * px)\n\n        // draw datasets\n        for (let i = 0, n = datasets.length; i < n; i ++) {\n            const dataset = datasets[i]\n            const { source, tree } = dataset\n\n            if (source.length > 1) {\n                ctx.strokeStyle = dataset.options.lineColor\n                ctx.lineWidth = dataset.options.lineWidth * px\n\n                const p0 = vec2()\n                const p1 = vec2()\n\n                const renderNode = (ctx, node, source) => {\n                    transform(p1, [ node.maxX, node.maxY ])\n                    if (p1[0] < 0) { return }\n                    transform(p0, [ node.minX, node.minY ])\n                    if (p0[0] > w) { return }\n                    const x0 = Math.round(p0[0])\n                    const x1 = Math.round(p1[0])\n                    if (x0 === x1) {\n                        ctx.beginPath()\n                        ctx.setLineDash(dataset.options.lineDash.map(x => x * px))\n                        ctx.moveTo(x0, p0[1])\n                        ctx.lineTo(x1, p1[1])\n                        ctx.stroke()\n                    } else if (node.left && node.right) {\n                        renderNode(ctx, node.left, source)\n                        renderNode(ctx, node.right, source)\n                    } else {\n                        ctx.beginPath()\n                        ctx.setLineDash(dataset.options.lineDash.map(x => x * px))\n                        transform(p0, source.at(node.s))\n                        ctx.moveTo(p0[0], p0[1])\n                        for (let j = node.s + 1; j <= node.e; j ++) { // TODO use source.forEach\n                            transform(p0, source.at(j))\n                            ctx.lineTo(p0[0], p0[1])\n                        }\n                        ctx.stroke()\n                    }\n                    ctx.setLineDash([])\n                }\n\n                const renderNodeStepped = (ctx, node, source) => {\n                    transform(p1, [ node.maxX, node.maxY ])\n                    if (p1[0] < 0) { return }\n                    transform(p0, [ node.minX, node.minY ])\n                    if (p0[0] > w) { return }\n                    const x0 = Math.round(p0[0])\n                    const x1 = Math.round(p1[0])\n                    if (x0 === x1) {\n                        ctx.beginPath()\n                        ctx.setLineDash(dataset.options.lineDash.map(x => x * px))\n                        ctx.moveTo(x0, p0[1])\n                        ctx.lineTo(x1, p1[1])\n                        ctx.stroke()\n                    } else if (node.left && node.right) {\n                        renderNodeStepped(ctx, node.left, source)\n                        renderNodeStepped(ctx, node.right, source)\n                    } else {\n                        ctx.beginPath()\n                        ctx.setLineDash(dataset.options.lineDash.map(x => x * px))\n                        transform(p0, source.at(node.s))\n                        ctx.moveTo(p0[0], p0[1])\n                        let y = p0[1]\n                        for (let j = node.s + 1; j <= node.e; j ++) { // TODO use source.forEach\n                            transform(p0, source.at(j))\n                            ctx.lineTo(p0[0], y)\n                            ctx.lineTo(p0[0], p0[1])\n                            y = p0[1]\n                        }\n                        ctx.stroke()\n                    }\n                    ctx.setLineDash([])\n                }\n\n                const PI2 = 2 * Math.PI\n\n                const renderNodePoints = (ctx, node, source, r) => {\n                    transform(p1, [ node.maxX, node.maxY ])\n                    if (p1[0] < 0) { return }\n                    transform(p0, [ node.minX, node.minY ])\n                    if (p0[0] > w) { return }\n                    const x0 = Math.round(p0[0])\n                    const x1 = Math.round(p1[0])\n                    if (x0 === x1) {\n                        ctx.beginPath()\n                        ctx.arc(x0, p0[1], r, 0, PI2, false)\n                        ctx.fill()\n                        ctx.beginPath()\n                        ctx.arc(x1, p1[1], r, 0, PI2, false)\n                        ctx.stroke()\n                    } else if (node.left && node.right) {\n                        renderNodePoints(ctx, node.left, source, r)\n                        renderNodePoints(ctx, node.right, source, r)\n                    } else {\n                        for (let j = node.s; j <= node.e; j ++) {\n                            transform(p0, source.at(j))\n                            ctx.beginPath()\n                            ctx.arc(p0[0], p0[1], r, 0, PI2, false)\n                            ctx.fill()\n                        }\n                        ctx.stroke()\n                    }\n                }\n\n                if (dataset.options.isStepped) {\n                    renderNodeStepped(ctx, tree, source)\n                } else {\n                    renderNode(ctx, tree, source)\n                }\n                const r = dataset.options.pointRadius\n                if (r > 0) {\n                    ctx.fillStyle = dataset.options.lineColor\n                    renderNodePoints(ctx, tree, source, r * px)\n                }\n            }\n        }\n\n        // draw labels\n        if (opts.xAxisLabelEnable || opts.yAxisLabelEnable) {\n            const fs = opts.fontSize * px\n            ctx.font = `${fs}px/1 ${opts.fontFamily}`\n            ctx.fillStyle = opts.axesColor\n            this.currentXBounds[0] = (0 - o[0]) / su[0] * gridScale[0] * u[0]\n            this.currentXBounds[1] = (w - o[0]) / su[0] * gridScale[0] * u[0]\n            if (opts.xAxisLabelEnable) {\n                const xOffset = opts.xAxisLabelXOffset * px\n                const yOffset = opts.xAxisLabelYOffset * px\n                const markOffset = opts.xAxisLabelMarkOffset * px\n                const markSize = opts.xAxisLabelMarkSize * px\n                const spacing = opts.xAxisLabelSpacing * px\n                const halfSpacing = spacing / 2\n                let labels = []\n                let labelsOutOfTopBound = false\n                let labelsOutOfBottomBound = false\n                for (let x = stx; x <= w; x += su[0]) {\n                    const delta = x - o[0]\n                    const i = Math.round(delta / su[0]) // index of grid line\n                    const t = i * gridScale[0] // parametric value of grid line\n                    const v = t * u[0] // value of grid line\n                    const text = opts.xAxisLabelFormat(v)\n                    const textMetrics = ctx.measureText(text)\n                    const label = {\n                        i,\n                        gridX: x,\n                        text,\n                        textMetrics,\n                        x: x - textMetrics.width / 2 + xOffset,\n                        y: o[1] + fs + yOffset\n                    }\n                    labels.push(label)\n                    if (label.y - fs - yOffset < 0) {\n                        labelsOutOfTopBound = true\n                    }\n                    if (label.y + yOffset > h) {\n                        labelsOutOfBottomBound = true\n                    }\n                }\n                for (let i = 0, n = labels.length; i < n; i ++) { // TODO compute y once for all x-labels\n                    const label = labels[i]\n                    y = label.y\n                    if (opts.xAxisLabelDynamicPosition) {\n                        y = labelsOutOfTopBound\n                            ? fs + yOffset\n                            : labelsOutOfBottomBound\n                                ? h - yOffset\n                                : y\n                    }\n                    const boundingRect = new DOMRect(\n                        label.x - halfSpacing,\n                        y - fs,\n                        label.textMetrics.width + spacing,\n                        fs\n                    )\n                    label.y = y\n                    label.boundingRect = boundingRect\n                }\n                // remove intersected labels\n                let joiningStep = opts.xAxisLabelJoiningStep\n                let srcLabels = labels\n                while (isNodesIntersects(labels)) {\n                    labels = srcLabels.filter(label => isZero(Math.abs(label.i) % joiningStep))\n                    joiningStep += opts.xAxisLabelJoiningStep\n                }\n                // render labels\n                for (let i = 0, n = labels.length; i < n; i ++) {\n                    const label = labels[i]\n                    if (!opts.xAxisLabelDisplayZero && label.i === 0) {\n                        continue\n                    }\n                    ctx.fillRect(label.gridX, o[1] + markOffset, px, markSize)\n                    ctx.fillText(\n                        label.text,\n                        label.x,\n                        label.y\n                    )\n                }\n            }\n            if (opts.yAxisLabelEnable) {\n                const xOffset = opts.yAxisLabelXOffset * px\n                const yOffset = opts.yAxisLabelYOffset * px\n                const markOffset = opts.yAxisLabelMarkOffset * px\n                const markSize = opts.yAxisLabelMarkSize * px\n                const spacing = opts.yAxisLabelSpacing * px\n                const halfSpacing = spacing / 2\n                let labels = []\n                let maxWidth = 0\n                let labelsOutOfLeftBound = false\n                let labelsOutOfRightBound = false\n                for (let y = sty; y <= h; y += su[1]) {\n                    const delta = o[1] - y\n                    const i = Math.round(delta / su[1]) // index of grid line\n                    const t = i * gridScale[1] // parametric value of grid line\n                    const v = t * u[1] // value of grid line\n                    const text = opts.yAxisLabelFormat(v)\n                    const textMetrics = ctx.measureText(text)\n                    const label = {\n                        i,\n                        gridY: y,\n                        text,\n                        textMetrics,\n                        x: o[0] - textMetrics.width + xOffset,\n                        y: y + fs/2 + yOffset\n                    }\n                    labels.push(label)\n                    if (maxWidth < textMetrics.width) {\n                        maxWidth = textMetrics.width\n                    }\n                    if (label.x + xOffset < 0) {\n                        labelsOutOfLeftBound = true\n                    }\n                    if (label.x + label.textMetrics.width - xOffset > w) {\n                        labelsOutOfRightBound = true\n                    }\n                }\n                for (let i = 0, n = labels.length; i < n; i ++) { // TODO compute x once for all y-labels\n                    const label = labels[i]\n                    x = label.x\n                    if (opts.yAxisLabelDynamicPosition) {\n                        x = labelsOutOfLeftBound\n                            ? maxWidth - label.textMetrics.width - xOffset\n                            : labelsOutOfRightBound\n                                ? w - label.textMetrics.width + xOffset\n                                : x\n                    }\n                    const boundingRect = new DOMRect(\n                        x,\n                        label.y - fs - halfSpacing,\n                        label.textMetrics.width,\n                        fs + spacing\n                    )\n                    label.x = x\n                    label.boundingRect = boundingRect\n                }\n                // remove intersected labels\n                let joiningStep = opts.yAxisLabelJoiningStep\n                let srcLabels = labels\n                while (isNodesIntersects(labels)) {\n                    labels = srcLabels.filter(label => isZero(Math.abs(label.i) % joiningStep))\n                    joiningStep += opts.yAxisLabelJoiningStep\n                }\n                labels = labels.filter(label => label.boundingRect.bottom > 0 && label.boundingRect.top < h)\n                // recompute intersections after removing intersected labels\n                maxWidth = 0\n                labelsOutOfLeftBound = false\n                labelsOutOfRightBound = false\n                for (let i = 0, n = labels.length; i < n; i ++) {\n                    const label = labels[i]\n                    label.x = o[0] - label.textMetrics.width + xOffset\n                    if (maxWidth < label.textMetrics.width) {\n                        maxWidth = label.textMetrics.width\n                    }\n                    if (label.x + xOffset < 0) {\n                        labelsOutOfLeftBound = true\n                    }\n                    if (label.x + label.textMetrics.width - xOffset > w) {\n                        labelsOutOfRightBound = true\n                    }\n                }\n                for (let i = 0, n = labels.length; i < n; i ++) { // TODO compute x once for all y-labels\n                    const label = labels[i]\n                    x = label.x\n                    if (opts.yAxisLabelDynamicPosition) {\n                        x = labelsOutOfLeftBound\n                            ? maxWidth - label.textMetrics.width - xOffset\n                            : labelsOutOfRightBound\n                                ? w - label.textMetrics.width + xOffset\n                                : x\n                    }\n                    label.x = x\n                }\n                // render labels\n                for (let i = 0, n = labels.length; i < n; i ++) {\n                    const label = labels[i]\n                    if (!opts.yAxisLabelDisplayZero && label.i === 0) {\n                        continue\n                    }\n                    ctx.fillRect(o[0] + markOffset, label.gridY, markSize, px)\n                    ctx.fillText(\n                        label.text,\n                        label.x,\n                        label.y\n                    )\n                }\n            }\n        }\n\n        // draw hints\n        if (opts.hints) {\n            const { createHints, displaceHints, renderHints } = opts.hints\n            let hints = createHints(\n                ctx,\n                this.focusPoint,\n                { width: w, height: h, pixelRatio: px },\n                datasets,\n                opts,\n                {\n                    transform,\n                    isIntersects,\n                    // measureText: text => ctx.measureText(text)\n                }\n            )\n            hints = displaceHints(hints)\n            renderHints(hints)\n        }\n\n        // disable clipping\n        if (clipPath) {\n            ctx.restore()\n        }\n\n        // callback\n        if (opts.afterRepaint) {\n            opts.afterRepaint()\n        }\n    }\n}\n\nexport default Chart\n", "const buildTree = (source, s, e, T) => {\n    const isLeaf = (e - s) <= T\n    let [ minX, minY ] = source.at(s)\n    let [ maxX, maxY ] = source.at(e)\n    let left\n    let right\n    if (isLeaf) {\n        for (let i = s; i <= e; i ++) {\n            const y = source.at(i)[1]\n            if (minY > y) {\n                minY = y\n            }\n            if (maxY < y) {\n                maxY = y\n            }\n        }\n    } else {\n        const h = Math.floor((e - s) / 2)\n        const m = s + h\n        left = buildTree(source, s, m, T)\n        right = buildTree(source, m, e, T)\n        minY = Math.min(left.minY, right.minY)\n        maxY = Math.max(left.maxY, right.maxY)\n    }\n    return {\n        s,\n        e,\n        minX,\n        minY,\n        maxX,\n        maxY,\n        left,\n        right\n    }\n}\n\nclass Dataset {\n\n    constructor(legend = '', options = {}) { // TODO use mergeOptions\n        if (!('groupId' in options)) {\n            options.groupId = null\n        }\n        if (!('lineColor' in options)) {\n            const f = () => Math.round(Math.random() * 256)\n            options.lineColor = `rgb(${f()},${f()},${f()})`\n        }\n        if (!('isStepped' in options)) {\n            options.isStepped = false\n        }\n        if (!('lineWidth' in options)) {\n            options.lineWidth = 1\n        }\n        if (!('lineDash' in options)) {\n            options.lineDash = []\n        }\n        if (!('pointRadius' in options)) {\n            options.pointRadius = 0\n        }\n        this.legend = legend\n        this.options = options\n    }\n\n    compile(source, T) {\n        this.source = source\n        this.rebuild(T)\n    }\n\n    rebuild(T = 100) {\n        const source = this.source\n        const length = source.length\n        this.tree = length > 0 ? buildTree(source, 0, length - 1, T) : null\n    }\n\n    getExtremes(initialMinX = null, initialMinY = null, initialMaxX = null, initialMaxY = null) { // TODO use tree\n        let minX = initialMinX\n        let maxX = initialMaxX\n        let minY = initialMinY\n        let maxY = initialMaxY\n        const { source } = this\n        for (let i = 0, n = source.length; i < n; i ++) {\n            const [ x, y ] = source.at(i)\n            if (minX === null || minX > x) {\n                minX = x\n            }\n            if (maxX === null || maxX < x) {\n                maxX = x\n            }\n            if (minY === null || minY > y) {\n                minY = y\n            }\n            if (maxY === null || maxY < y) {\n                maxY = y\n            }\n        }\n        return { minX, minY, maxX, maxY }\n    }\n\n    getBoundingRect() { // DEPRECATED\n        const { minX, minY, maxX, maxY } = this.getExtremes()\n        const rect = new DOMRect(minX, minY, maxX - minX, maxY - minY)\n        rect.minX = minX\n        rect.minY = minY\n        rect.maxX = maxX\n        rect.maxY = maxY\n        return rect\n    }\n}\n\nexport default Dataset\n"],
  "mappings": "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",
  "names": ["isZero", "x", "eps", "vec2", "y", "vec2clone", "p", "vec2copy", "r", "p", "vec2add", "p1", "p2", "vec2sub", "vec2mul", "vec2div", "vec2lerp", "s", "vec2neglerp", "vec2muladd", "r", "p", "s", "t", "vec2subdiv", "findLess_default", "compareWithSync", "low", "high", "result", "mid", "cmp", "dropEvent", "evt", "POINTER_DOWN", "POINTER_MOVE", "POINTER_UP", "POINTER_ZOOM", "defaultOptions", "TouchGestures", "element", "options", "opts", "fireEvent", "name", "detail", "pointerdown", "originalEvent", "x", "y", "pointerup", "pointerzoom", "deltaScale", "pointermove", "dx", "dy", "touchId", "secondTouchId", "touchPoint", "secondTouchPoint", "wheelDirection", "wheelStep", "clientRect", "touch", "touches", "secondTouch", "touchNewPoint", "secondTouchNewPoint", "dxNew", "dyNew", "previousLength", "length", "point", "pointNew", "isObject", "o", "isArray", "a", "mergeObjects", "b", "result", "k", "v", "defaultHintsSettings", "dataset", "defaultSettings", "createHints", "ctx", "focusPoint", "viewport", "datasets", "opts", "helpers", "fontFamily", "fontSize", "hintText", "passedSettings", "settings", "mergeObjects", "focus", "borderRadius", "paddingOrigin", "markOrigin", "splitterOrigin", "innerRadius", "outerRadius", "p", "vec2", "transform", "list", "pixelRatio", "mark", "padding", "splitter", "fs", "i", "n", "contents", "fullWidth", "fullHeight", "correction", "j", "m", "metrics", "width", "ascent", "descent", "offsetX", "offsetY", "displaceHints", "hints", "height", "isIntersects", "splitterHeight", "listNext", "a", "b", "isChanged", "numIterations", "delta", "k", "renderHints", "font", "color", "shadow", "axes", "backgroundColor", "item", "left", "top", "right", "bottom", "lineWidth", "focusPoints", "y", "blur", "xOrigin", "yOrigin", "lineColor", "x", "border", "background", "text", "texts", "marks", "offsetLeft", "offsetTop", "l", "defaultLegendsSettings", "defaultSettings", "createLegends", "ctx", "viewport", "datasets", "opts", "legendText", "passedSettings", "settings", "mergeObjects", "itemPaddingOrigin", "paddingOrigin", "markOrigin", "fontFamily", "fontSize", "list", "maxWidth", "correction", "pixelRatio", "fs", "mark", "padding", "itemPadding", "legends", "groups", "dataset", "i", "groupId", "a", "b", "n", "content", "metrics", "width", "ascent", "descent", "availWidth", "numColumns", "maxColumnsUsed", "maxRowsUsed", "rowHeight", "item", "columnIndex", "rowIndex", "legendsHeight", "shiftX", "shiftY", "renderLegends", "area", "font", "color", "backgroundColor", "left", "top", "right", "bottom", "text", "lineColor", "offsetLeft", "offsetTop", "innerRadius", "outerRadius", "x", "isIntersects", "r1", "r2", "isNodesIntersects", "nodes", "n", "i", "j", "defaultOptions", "x", "y", "defaultHintsSettings", "dataset", "opts", "pointSource", "createHints", "displaceHints", "renderHints", "defaultLegendsSettings", "createLegends", "renderLegends", "Chart", "elCanvas", "options", "mergeObjects", "vec2", "mouseState", "pointFromMouseEvent", "evt", "left", "right", "top", "bottom", "POINTER_DOWN", "POINTER_UP", "POINTER_MOVE", "isInsideCanvas", "vec2sub", "vec2copy", "delta", "r", "vec2subdiv", "vec2mul", "vec2div", "POINTER_ZOOM", "deltaScale", "doScaleX", "doScaleY", "TouchGestures", "p", "source", "length", "i0", "findLess_default", "i1", "p1", "p2", "t", "vec2lerp", "evtName", "vec2clone", "boundingRect", "keepAspectRatio", "w", "h", "bRect", "px", "canvasStep", "axesStep", "dw", "dh", "initialMinX", "initialMinY", "initialMaxX", "initialMaxY", "minX", "maxX", "minY", "maxY", "extremes", "rect", "vec2add", "pt", "o", "s", "vec2neglerp", "vec2muladd", "ctx", "datasets", "su", "u", "gridScale", "subdivisions", "stx", "sty", "transform", "clipPath", "legends", "tree", "p0", "renderNode", "node", "x0", "x1", "renderNodeStepped", "PI2", "renderNodePoints", "fs", "xOffset", "yOffset", "markOffset", "markSize", "spacing", "halfSpacing", "labels", "labelsOutOfTopBound", "labelsOutOfBottomBound", "v", "text", "textMetrics", "label", "joiningStep", "srcLabels", "isZero", "maxWidth", "labelsOutOfLeftBound", "labelsOutOfRightBound", "hints", "Chart_default", "buildTree", "source", "s", "e", "T", "isLeaf", "minX", "minY", "maxX", "maxY", "left", "right", "i", "y", "h", "Dataset", "legend", "options", "f", "length", "initialMinX", "initialMinY", "initialMaxX", "initialMaxY", "n", "x", "rect", "Dataset_default"]
}
