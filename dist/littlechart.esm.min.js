var e={d:(t,i)=>{for(var s in i)e.o(i,s)&&!e.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:i[s]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};function i(e,t=.001){return Math.abs(e)<t}function s(e=0,t=0){return[e,t]}function n(e,t){return e[0]=t[0],e[1]=t[1],e}function l(e,t,i){return e[0]=t[0]*i[0],e[1]=t[1]*i[1],e}function o(e,t,i){return e[0]=t[0]/i[0],e[1]=t[1]/i[1],e}function a(e,t,i,s){return e[0]=t[0]*i[0]+s[0],e[1]=t[1]*i[1]+s[1],e}e.d(t,{k:()=>m,q:()=>g});const r=e=>{e.preventDefault(),e.stopPropagation(),console.log("drop",e.type)},c="sim:pointerdown",h="sim:pointermove",u="sim:pointerup",f="sim:pointerzoom",x={listenerElement:null,invertMouseWheel:!1,mouseWheelStep:.1};class d{constructor(e,t={}){const i={...x,...t};this.element=e,this.listenerElement=null!==i.listenerElement?i.listenerElement:e;const s=(e,t)=>this.element.dispatchEvent(new CustomEvent(e,{detail:t})),n=(e,t,i)=>s(c,{originalEvent:e,clientX:t,clientY:i}),l=(e,t,i)=>s(u,{originalEvent:e,clientX:t,clientY:i}),o=(e,t,i,n)=>s(f,{originalEvent:e,clientX:t,clientY:i,deltaScale:n}),a=(e,t,i,n,l)=>s(h,{originalEvent:e,clientX:t,clientY:i,movementX:n,movementY:l});let r=null,d=null;const p={x:0,y:0},y={x:0,y:0},b=i.invertMouseWheel?-1:1,m=i.mouseWheelStep;this.listeners={touchstart:e=>{let t;const i=e.target.getBoundingClientRect();if(null!==r){const s=e.changedTouches[0];if(s.identifier!==r){let o;d=s.identifier,y.x=s.clientX-i.left,y.y=s.clientY-i.top,o=l(e,p.x,p.y),!1===o&&(t=!1),o=n(e,p.x+(y.x-p.x)/2,p.y+(y.y-p.y)/2),!1===o&&(t=!1)}}else{const s=e.changedTouches[0];let l;r=s.identifier,p.x=s.clientX-i.left,p.y=s.clientY-i.top,l=n(e,p.x,p.y),!1===l&&(t=!1)}return!1===t&&(e.stopPropagation(),e.preventDefault()),t},touchend:e=>{let t,i=Array.from(e.changedTouches);if(null!==r&&null!==d){const s=i.find((e=>r===e.identifier)),o=i.find((e=>d===e.identifier));let a;a=l(e,p.x+(y.x-p.x)/2,p.y+(y.y-p.y)/2),!1===a&&(t=!1),s&&o?(r=null,d=null):s&&!o?(r=d,p.x=y.x,p.y=y.y,d=null):!s&&o&&(d=null),null!==r&&(a=n(e,p.x,p.y),!1===a&&(t=!1))}else if(null!==r&&i.find((e=>r===e.identifier))){let i;r=null,i=l(e,p.x,p.y),!1===i&&(t=!1)}return!1===t&&(e.stopPropagation(),e.preventDefault()),t},touchmove:e=>{let t;const i=e.target.getBoundingClientRect();if(null!==r&&null!==d){const s={x:p.x,y:p.y},c={x:y.x,y:y.y},h=Array.from(e.changedTouches).find((e=>r===e.identifier)),u=Array.from(e.changedTouches).find((e=>d===e.identifier));h&&(s.x=h.clientX-i.left,s.y=h.clientY-i.top),u&&(c.x=u.clientX-i.left,c.y=u.clientY-i.top);const f=y.x-p.x,x=y.y-p.y,b=c.x-s.x,m=c.y-s.y,g=1-Math.hypot(f,x)/Math.hypot(b,m),v={x:p.x+f/2,y:p.y+x/2},L={x:s.x+b/2,y:s.y+m/2};let E;E=a(e,L.x,L.y,L.x-v.x,L.y-v.y),!1===E&&(t=!1),E=l(e,L.x,L.y),!1===E&&(t=!1),E=o(e,L.x,L.y,g),!1===E&&(t=!1),E=n(e,L.x,L.y),!1===E&&(t=!1),p.x=s.x,p.y=s.y,y.x=c.x,y.y=c.y}else if(null!==r){const s={x:p.x,y:p.y},n=Array.from(e.changedTouches).find((e=>r===e.identifier));if(!n)return;let l;s.x=n.clientX-i.left,s.y=n.clientY-i.top,l=a(e,s.x,s.y,s.x-p.x,s.y-p.y),!1===l&&(t=!1),p.x=s.x,p.y=s.y}return!1===t&&(e.stopPropagation(),e.preventDefault()),t},mousedown:e=>{p.x=e.clientX,p.y=e.clientY;let t=n(e,p.x,p.y);return!1===t&&(e.stopPropagation(),e.preventDefault()),t},mouseup:e=>{p.x=e.clientX,p.y=e.clientY;let t=l(e,p.x,p.y);return!1===t&&(e.stopPropagation(),e.preventDefault()),t},mousemove:e=>{let t={x:e.clientX,y:e.clientY},i=a(e,t.x,t.y,t.x-p.x,t.y-p.y);return p.x=t.x,p.y=t.y,!1===i&&(e.stopPropagation(),e.preventDefault()),i},wheel:e=>{const t=m*(e.deltaY>0?1:-1)*b,i=o(e,e.clientX,e.clientY,t);return!1===i&&(e.stopPropagation(),e.preventDefault()),i}}}enableNativeGestures(){document.removeEventListener("gesturestart",r),document.removeEventListener("gesturechange",r),document.removeEventListener("gestureend",r)}disableNativeGestures(){document.addEventListener("gesturestart",r),document.addEventListener("gesturechange",r),document.addEventListener("gestureend",r)}enableTouchGestures(){this.listenerElement.addEventListener("touchstart",this.listeners.touchstart),document.addEventListener("touchend",this.listeners.touchend),document.addEventListener("touchmove",this.listeners.touchmove)}disableTouchGestures(){this.listenerElement.removeEventListener("touchstart",this.listeners.touchstart),document.removeEventListener("touchend",this.listeners.touchend),document.removeEventListener("touchmove",this.listeners.touchmove)}enableMouseGestures(){this.listenerElement.addEventListener("mousedown",this.listeners.mousedown),document.addEventListener("mouseup",this.listeners.mouseup),document.addEventListener("mousemove",this.listeners.mousemove),this.listenerElement.addEventListener("wheel",this.listeners.wheel),document.addEventListener("mouseleave",this.listeners.mouseup)}disableMouseGestures(){this.listenerElement.removeEventListener("mousedown",this.listeners.mousedown),document.removeEventListener("mouseup",this.listeners.mouseup),document.removeEventListener("mousemove",this.listeners.mousemove),document.removeEventListener("wheel",this.listeners.wheel),document.removeEventListener("mouseleave",this.listeners.mouseup)}}d.EVT_NAME_POINTERDOWN=c,d.EVT_NAME_POINTERMOVE=h,d.EVT_NAME_POINTERUP=u,d.EVT_NAME_POINTERZOOM=f;const p=d;function y(e){const t=e.length;for(let n=0;n<t;n++)for(let l=0;l<t;l++)if(n!==l&&(i=e[n].boundingRect,s=e[l].boundingRect,i.bottom>s.top&&i.right>s.left&&i.top<s.bottom&&i.left<s.right))return!0;var i,s;return!1}const b={xCanvasStep:25,yCanvasStep:25,xAxisStep:1,yAxisStep:1,xOffset:0,yOffset:0,xScale:1,yScale:1,xAxisSubdivisions:10,yAxisSubdivisions:10,lineWidth:1,pointSize:0,fontSize:15,fontFamily:"monospace",xAxisLabelXOffset:0,xAxisLabelYOffset:0,xAxisLabelDynamicPosition:!0,xAxisLabelSpacing:15,xAxisLabelFormat:e=>e.toFixed(4),xAxisLabelJoiningStep:5,xAxisLabelMarkOffset:-2,xAxisLabelMarkSize:4,xAxisLabelDisplayZero:!0,xAxisLabelEnable:!0,yAxisLabelXOffset:0,yAxisLabelYOffset:0,yAxisLabelDynamicPosition:!0,yAxisLabelSpacing:0,yAxisLabelFormat:e=>e.toFixed(4),yAxisLabelJoiningStep:5,yAxisLabelMarkOffset:-2,yAxisLabelMarkSize:4,yAxisLabelDisplayZero:!0,yAxisLabelEnable:!0,backgroundColor:"#ffffff",gridColor:"rgba(0,0,0,0.1)",axesColor:"rgba(0,0,0,0.5)",userTranslateX:!0,userTranslateY:!0,userScaleX:!0,userScaleY:!0,canvasRatio:1,canvasPixelRatio:1,clearFrame:!1,pointsOfInterestEnable:!1,pointsOfInterestLabelFormat:(e,t,i,s)=>`X: ${s.xAxisLabelFormat(e)}\nY: ${s.yAxisLabelFormat(t)}`,pointsOfInterestLabelOffsetX:15,pointsOfInterestLabelOffsetY:0,pointsOfInterestLabelPaddingLeft:10,pointsOfInterestLabelPaddingRight:10,pointsOfInterestLabelPaddingTop:5,pointsOfInterestLabelPaddingBottom:5,pointsOfInterestRadius:3,pointsOfInterestXAxisEnable:!0,pointsOfInterestYAxisEnable:!0,pointsOfInterestAxesColor:"rgba(0,0,0,0.1)",pointsOfInterestLabelBackgroundColor:"rgba(0,0,0,1)",pointsOfInterestLabelColor:"rgba(255,255,255,1)",cursorPointer:"pointer",cursorGrabbing:"grabbing",bindEventHandlers:!0,invertMouseWheel:!1,mouseWheelStep:.1},m=class{constructor(e,t={}){this.options=t={...b,...t},this.elCanvas=e,this.ctx=e.getContext("2d"),this.scale=s(t.xScale,t.yScale),this.translate=s(t.xOffset,t.yOffset),this.poi=s(0,0),this.datasets=[],e.style.cursor=t.cursorPointer;const i={down:!1,pt0:s(0,0),pt:s(0,0),delta:s(0,0)},a=(i,s)=>{const{clientX:n,clientY:l}=s,{left:o,right:a,top:r,bottom:c}=e.getBoundingClientRect();return i[0]=(n-o)/t.canvasRatio,i[1]=(l-r)/t.canvasRatio,o<=n&&n<=a&&r<=l&&l<=c};this.isListening=!1,this.listeners={},this.listeners[p.EVT_NAME_POINTERDOWN]=s=>{e.style.cursor=t.cursorGrabbing,s.detail.originalEvent.preventDefault(),i.down=!0,a(i.pt0,s.detail)},this.listeners[p.EVT_NAME_POINTERUP]=s=>{i.down=!1,e.style.cursor=t.cursorPointer},this.listeners[p.EVT_NAME_POINTERMOVE]=e=>{const r=a(i.pt,e.detail);if(i.down){c=i.delta,h=i.pt,u=i.pt0,c[0]=h[0]-u[0],c[1]=h[1]-u[1],n(i.pt0,i.pt);const e=s(t.userTranslateX?i.delta[0]:0,t.userTranslateY?i.delta[1]:0);this.move(e),this.repaint()}else if(t.pointsOfInterestEnable&&r){const e=s();!function(e,t,i,s){e[0]=(t[0]-s[0])/i[0],e[1]=(t[1]-s[1])/i[1]}(e,i.pt,s(t.xCanvasStep,t.yCanvasStep),this.translate),e[1]=-e[1],l(e,e,s(t.xAxisStep,t.yAxisStep)),o(e,e,this.scale),this.computePointsOfInterest(e),this.repaint()}var c,h,u},this.listeners[p.EVT_NAME_POINTERZOOM]=e=>{e.detail.originalEvent.preventDefault();const n=e.detail.deltaScale,l=s(t.userScaleX?n:0,t.userScaleY?n:0);a(i.pt,e.detail),this.zoomAroundPoint(l,i.pt),this.repaint()},this.touchGestures=new p(e,{invertMouseWheel:t.invertMouseWheel,mouseWheelStep:t.mouseWheelStep}),t.bindEventHandlers&&this.bind()}computePointsOfInterest(e){this.datasets.forEach((t=>{const i=t.points,n=((e,t,s,n)=>{let l=-1;for(;t<=s;){let e=t+Math.floor((s-t+1)/2),o=i[e][0];o<n?(l=e,t=e+1):(o>n||o===n)&&(s=e-1)}return l})(0,0,i.length-1,e[0]),l=n+1;if(n>=0&&l<i.length){const o=s(),a=i[n],r=i[l],c=(e[0]-a[0])/(r[0]-a[0]);!function(e,t,i,s){e[0]=t[0]+s[0]*(i[0]-t[0]),e[1]=t[1]+s[1]*(i[1]-t[1])}(o,a,r,s(c,t.options.isStepped?0:c)),t.poi=o}else t.poi=null})),n(this.poi,e)}bind(){if(!this.isListening){for(let e in this.listeners)this.elCanvas.addEventListener(e,this.listeners[e]);this.touchGestures.enableTouchGestures(),this.touchGestures.enableMouseGestures(),this.isListening=!0}}unbind(){if(this.isListening){for(let e in this.listeners)this.elCanvas.removeEventListener(e,this.listeners[e]);this.touchGestures.disableTouchGestures(),this.touchGestures.disableMouseGestures(),this.isListening=!1}}fitView(e,t=!0){let i=this.elCanvas.width,n=this.elCanvas.height;if(i<=0||n<=0||Math.abs(e.width)<=0||Math.abs(e.height)<=0)return!1;const l=new DOMRect(e.x,-e.y-e.height,e.width,e.height),o=this.options,a=o.canvasRatio*o.canvasPixelRatio,r=s(o.xCanvasStep,o.yCanvasStep),c=s(o.xAxisStep,o.yAxisStep);if(i=i/a/r[0]*c[0],n=n/a/r[1]*c[1],this.scale[0]=i/l.width,this.scale[1]=n/l.height,t&&(this.scale[1]>this.scale[0]?this.scale[1]=this.scale[0]:this.scale[0]=this.scale[1]),this.translate[0]=-l.x/c[0]*r[0]*this.scale[0],this.translate[1]=-l.y/c[1]*r[1]*this.scale[1],t){const e=(i/this.scale[0]-l.width)/2,t=(n/this.scale[1]-l.height)/2;this.translate[0]+=e*r[0]*this.scale[0]/c[0],this.translate[1]+=t*r[1]*this.scale[1]/c[1]}return!0}fitViewAuto(e=!0){this.fitView(this.getBoundingRect(null,0,null,0),e),this.repaint()}getBoundingRect(e=null,t=null,i=null,s=null){let n=e,l=i,o=t,a=s;for(let e=0,t=this.datasets.length;e<t;e++)for(let t=0,i=this.datasets[e].points,s=i.length;t<s;t++){const[e,s]=i[t];(null===n||n>e)&&(n=e),(null===l||l<e)&&(l=e),(null===o||o>s)&&(o=s),(null===a||a<s)&&(a=s)}const r=new DOMRect(n,o,l-n,a-o);return r.minX=n,r.minY=o,r.maxX=l,r.maxY=a,r}move(e){var t,i,s;t=this.translate,i=this.translate,s=e,t[0]=i[0]+s[0],t[1]=i[1]+s[1]}zoomAroundPoint(e,t){const i=this.translate,s=this.scale;!function(e,t,i,s){e[0]=t[0]-s[0]*(i[0]-t[0]),e[1]=t[1]-s[1]*(i[1]-t[1])}(i,i,t,e),a(s,s,e,s)}repaint(){let e,t;const n=this.options,r=this.ctx,c=this.elCanvas.width,h=this.elCanvas.height,u=this.scale;if(c<=0||h<=0||0===u[0]||0===u[1])return;const f=n.canvasRatio*n.canvasPixelRatio,x=s(n.xCanvasStep*f,n.yCanvasStep*f),d=s(this.translate[0]*f,this.translate[1]*f),p=s(x[0]*u[0],x[1]*u[1]),b=s(n.xAxisStep,n.yAxisStep),m=s(1,1),g=s(n.xAxisSubdivisions,n.yAxisSubdivisions);for(;p[0]>x[0]*g[0];)p[0]/=g[0],m[0]/=g[0];for(;p[1]>x[1]*g[1];)p[1]/=g[1],m[1]/=g[1];for(;p[0]<x[0];)p[0]*=g[0],m[0]*=g[0];for(;p[1]<x[1];)p[1]*=g[1],m[1]*=g[1];const v=d[0]-(Math.floor(d[0]/p[0])+(d[0]>0?1:0))*p[0],L=d[1]-(Math.floor(d[1]/p[1])+(d[1]>0?1:0))*p[1],E=(e,t)=>{l(e,t,x),o(e,e,b),e[1]=-e[1],a(e,e,u,d)},A=s();n.clearFrame&&r.clearRect(0,0,c,h),r.fillStyle=n.backgroundColor,r.fillRect(0,0,c,h),r.fillStyle=n.gridColor;for(let e=v;e<=c;e+=p[0])r.fillRect(e,0,1*f,h);for(let e=L;e<=h;e+=p[1])r.fillRect(0,e,c,1*f);r.fillStyle=n.axesColor,r.fillRect(d[0],0,1*f,h),r.fillRect(0,d[1],c,1*f),r.fillStyle=n.pointsOfInterestAxesColor;for(let e=0,t=this.datasets.length;e<t;e++){const t=this.datasets[e];n.pointsOfInterestEnable&&n.pointsOfInterestXAxisEnable&&t.poi&&(E(A,t.poi),r.fillRect(0,A[1],c,1*f))}n.pointsOfInterestEnable&&n.pointsOfInterestYAxisEnable&&(E(A,this.poi),r.fillRect(A[0],0,1*f,h));for(let e=0,i=this.datasets.length;e<i;e++){const i=this.datasets[e],s=i.points,n=s.length;if(n>1){if(r.strokeStyle=i.options.lineColor,r.lineWidth=i.options.lineWidth*f,r.beginPath(),E(A,s[0]),r.moveTo(A[0],A[1]),i.options.isStepped){t=A[1];for(let e=1;e<n;e++)E(A,s[e]),r.lineTo(A[0],t),r.lineTo(A[0],A[1]),t=A[1]}else for(let e=1;e<n;e++)E(A,s[e]),r.lineTo(A[0],A[1]);if(r.stroke(),i.options.pointRadius>0){r.fillStyle=i.options.lineColor;const e=i.options.pointRadius,t=2*Math.PI;E(A,s[0]),r.beginPath(),r.arc(A[0],A[1],e,0,t,!1),r.fill();for(let i=1;i<n;i++)E(A,s[i]),r.beginPath(),r.arc(A[0],A[1],e,0,t,!1),r.fill()}}}if(n.xAxisLabelEnable||n.yAxisLabelEnable){const s=n.fontSize*f;if(r.font=`${s}px/1 ${n.fontFamily}`,r.fillStyle=n.axesColor,n.xAxisLabelEnable){const e=n.xAxisLabelXOffset*f,l=n.xAxisLabelYOffset*f,o=n.xAxisLabelMarkOffset*f,a=n.xAxisLabelMarkSize*f,u=n.xAxisLabelSpacing*f,x=u/2;let g=[],L=!1,E=!1;for(let t=v;t<=c;t+=p[0]){const i=t-d[0],o=Math.round(i/p[0]),a=o*m[0]*b[0],c=n.xAxisLabelFormat(a),u=r.measureText(c),f={i:o,gridX:t,text:c,textMetrics:u,x:t-u.width/2+e,y:d[1]+s+l};g.push(f),f.y-s-l<0&&(L=!0),f.y+l>h&&(E=!0)}for(let e=0,i=g.length;e<i;e++){const i=g[e];t=i.y,n.xAxisLabelDynamicPosition&&(t=L?s+l:E?h-l:t);const o=new DOMRect(i.x-x,t-s,i.textMetrics.width+u,s);i.y=t,i.boundingRect=o}let A=n.xAxisLabelJoiningStep,O=g;for(;y(g);)g=O.filter((e=>i(Math.abs(e.i)%A))),A+=n.xAxisLabelJoiningStep;for(let e=0,t=g.length;e<t;e++){const t=g[e];(n.xAxisLabelDisplayZero||0!==t.i)&&(r.fillRect(t.gridX,d[1]+o,f,a),r.fillText(t.text,t.x,t.y))}}if(n.yAxisLabelEnable){const t=n.yAxisLabelXOffset*f,l=n.yAxisLabelYOffset*f,o=n.yAxisLabelMarkOffset*f,a=n.yAxisLabelMarkSize*f,u=n.yAxisLabelSpacing*f,x=u/2;let g=[],v=0,E=!1,A=!1;for(let e=L;e<=h;e+=p[1]){const i=d[1]-e,o=Math.round(i/p[1]),a=o*m[1]*b[1],h=n.yAxisLabelFormat(a),u=r.measureText(h),f={i:o,gridY:e,text:h,textMetrics:u,x:d[0]-u.width+t,y:e+s/2+l};g.push(f),v<u.width&&(v=u.width),f.x+t<0&&(E=!0),f.x+f.textMetrics.width-t>c&&(A=!0)}for(let i=0,l=g.length;i<l;i++){const l=g[i];e=l.x,n.yAxisLabelDynamicPosition&&(e=E?v-l.textMetrics.width-t:A?c-l.textMetrics.width+t:e);const o=new DOMRect(e,l.y-s-x,l.textMetrics.width,s+u);l.x=e,l.boundingRect=o}let O=n.yAxisLabelJoiningStep,S=g;for(;y(g);)g=S.filter((e=>i(Math.abs(e.i)%O))),O+=n.yAxisLabelJoiningStep;g=g.filter((e=>e.boundingRect.bottom>0&&e.boundingRect.top<h)),v=0,E=!1,A=!1;for(let e=0,i=g.length;e<i;e++){const i=g[e];i.x=d[0]-i.textMetrics.width+t,v<i.textMetrics.width&&(v=i.textMetrics.width),i.x+t<0&&(E=!0),i.x+i.textMetrics.width-t>c&&(A=!0)}for(let i=0,s=g.length;i<s;i++){const s=g[i];e=s.x,n.yAxisLabelDynamicPosition&&(e=E?v-s.textMetrics.width-t:A?c-s.textMetrics.width+t:e),s.x=e}for(let e=0,t=g.length;e<t;e++){const t=g[e];(n.yAxisLabelDisplayZero||0!==t.i)&&(r.fillRect(d[0]+o,t.gridY,a,f),r.fillText(t.text,t.x,t.y))}}}if(n.pointsOfInterestEnable){const e=n.fontSize*f;r.font=`${e}px/1 ${n.fontFamily}`;for(let e=0,t=this.datasets.length;e<t;e++){const t=this.datasets[e];if(n.pointsOfInterestEnable&&t.poi){E(A,t.poi),r.fillStyle=t.options.lineColor,r.beginPath(),r.arc(A[0],A[1],n.pointsOfInterestRadius,0,2*Math.PI,!1),r.fill();const e=n.pointsOfInterestLabelFormat(t.poi[0],t.poi[1],t,n).split("\n");let i=0,s=0,l=0;for(let t=0,o=e.length;t<o;t++){const o=e[t],a=r.measureText(o),c=a.width;i<c&&(i=c),s+=n.fontSize;const h=-Math.abs(a.actualBoundingBoxAscent),u=Math.abs(a.actualBoundingBoxDescent);l=n.fontSize-(u-h)}i+=n.pointsOfInterestLabelPaddingLeft+n.pointsOfInterestLabelPaddingRight,s+=n.pointsOfInterestLabelPaddingTop+n.pointsOfInterestLabelPaddingBottom+l;let o=A[0]+n.pointsOfInterestLabelOffsetX,a=A[1]+n.pointsOfInterestLabelOffsetY-s/2;r.fillStyle=n.pointsOfInterestLabelBackgroundColor,r.fillRect(o,a,i,s),o+=n.pointsOfInterestLabelPaddingLeft,a+=n.pointsOfInterestLabelPaddingTop,r.fillStyle=n.pointsOfInterestLabelColor;for(let t=0,i=e.length;t<i;t++)r.fillText(e[t],o,a+n.fontSize),a+=n.fontSize}}}}},g=class{constructor(e={}){if(!("lineColor"in e)){const t=()=>Math.round(256*Math.random());e.lineColor=`rgb(${t()},${t()},${t()})`}"isStepped"in e||(e.isStepped=!1),"lineWidth"in e||(e.lineWidth=1),"pointRadius"in e||(e.pointRadius=0),this.options=e,this.points=[]}getBoundingRect(){let e=null,t=null,i=null,s=null;for(let n=0,l=this.points,o=l.length;n<o;n++){const[o,a]=l[n];(null===e||e>o)&&(e=o),(null===t||t<o)&&(t=o),(null===i||i>a)&&(i=a),(null===s||s<a)&&(s=a)}const n=new DOMRect(e,i,t-e,s-i);return n.minX=e,n.minY=i,n.maxX=t,n.maxY=s,n}};var v=t.k,L=t.q;export{v as Chart,L as Dataset};