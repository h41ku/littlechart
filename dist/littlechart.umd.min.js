!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var i=e();for(var s in i)("object"==typeof exports?exports:t)[s]=i[s]}}(self,(()=>(()=>{"use strict";var t={d:(e,i)=>{for(var s in i)t.o(i,s)&&!t.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:i[s]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};function i(t,e=.001){return Math.abs(t)<e}function s(t=0,e=0){return[t,e]}function n(t,e){return t[0]=e[0],t[1]=e[1],t}function o(t,e,i){return t[0]=e[0]*i[0],t[1]=e[1]*i[1],t}function l(t,e,i){return t[0]=e[0]/i[0],t[1]=e[1]/i[1],t}function r(t,e,i,s){return t[0]=e[0]*i[0]+s[0],t[1]=e[1]*i[1]+s[1],t}t.r(e),t.d(e,{Chart:()=>S,Dataset:()=>L});const a=t=>{t.preventDefault(),t.stopPropagation(),console.log("drop",t.type)},c="sim:pointerdown",f="sim:pointermove",u="sim:pointerup",h="sim:pointerzoom",d={listenerElement:null,invertMouseWheel:!1,mouseWheelStep:.1};class x{constructor(t,e={}){const i={...d,...e};this.element=t,this.listenerElement=null!==i.listenerElement?i.listenerElement:t;const s=(t,e)=>this.element.dispatchEvent(new CustomEvent(t,{detail:e})),n=(t,e,i)=>s(c,{originalEvent:t,clientX:e,clientY:i}),o=(t,e,i)=>s(u,{originalEvent:t,clientX:e,clientY:i}),l=(t,e,i,n)=>s(h,{originalEvent:t,clientX:e,clientY:i,deltaScale:n}),r=(t,e,i,n,o)=>s(f,{originalEvent:t,clientX:e,clientY:i,movementX:n,movementY:o});let a=null,x=null;const p={x:0,y:0},g={x:0,y:0},m=i.invertMouseWheel?-1:1,y=i.mouseWheelStep;this.listeners={touchstart:t=>{let e;const i=t.target.getBoundingClientRect();if(null!==a){const s=t.changedTouches[0];if(s.identifier!==a){let l;x=s.identifier,g.x=s.clientX-i.left,g.y=s.clientY-i.top,l=o(t,p.x,p.y),!1===l&&(e=!1),l=n(t,p.x+(g.x-p.x)/2,p.y+(g.y-p.y)/2),!1===l&&(e=!1)}}else{const s=t.changedTouches[0];let o;a=s.identifier,p.x=s.clientX-i.left,p.y=s.clientY-i.top,o=n(t,p.x,p.y),!1===o&&(e=!1)}return!1===e&&(t.stopPropagation(),t.preventDefault()),e},touchend:t=>{let e,i=Array.from(t.changedTouches);if(null!==a&&null!==x){const s=i.find((t=>a===t.identifier)),l=i.find((t=>x===t.identifier));let r;r=o(t,p.x+(g.x-p.x)/2,p.y+(g.y-p.y)/2),!1===r&&(e=!1),s&&l?(a=null,x=null):s&&!l?(a=x,p.x=g.x,p.y=g.y,x=null):!s&&l&&(x=null),null!==a&&(r=n(t,p.x,p.y),!1===r&&(e=!1))}else if(null!==a&&i.find((t=>a===t.identifier))){let i;a=null,i=o(t,p.x,p.y),!1===i&&(e=!1)}return!1===e&&(t.stopPropagation(),t.preventDefault()),e},touchmove:t=>{let e;const i=t.target.getBoundingClientRect();if(null!==a&&null!==x){const s={x:p.x,y:p.y},c={x:g.x,y:g.y},f=Array.from(t.changedTouches).find((t=>a===t.identifier)),u=Array.from(t.changedTouches).find((t=>x===t.identifier));f&&(s.x=f.clientX-i.left,s.y=f.clientY-i.top),u&&(c.x=u.clientX-i.left,c.y=u.clientY-i.top);const h=g.x-p.x,d=g.y-p.y,m=c.x-s.x,y=c.y-s.y,b=1-Math.hypot(h,d)/Math.hypot(m,y),v={x:p.x+h/2,y:p.y+d/2},S={x:s.x+m/2,y:s.y+y/2};let L;L=r(t,S.x,S.y,S.x-v.x,S.y-v.y),!1===L&&(e=!1),L=o(t,S.x,S.y),!1===L&&(e=!1),L=l(t,S.x,S.y,b),!1===L&&(e=!1),L=n(t,S.x,S.y),!1===L&&(e=!1),p.x=s.x,p.y=s.y,g.x=c.x,g.y=c.y}else if(null!==a){const s={x:p.x,y:p.y},n=Array.from(t.changedTouches).find((t=>a===t.identifier));if(!n)return;let o;s.x=n.clientX-i.left,s.y=n.clientY-i.top,o=r(t,s.x,s.y,s.x-p.x,s.y-p.y),!1===o&&(e=!1),p.x=s.x,p.y=s.y}return!1===e&&(t.stopPropagation(),t.preventDefault()),e},mousedown:t=>{p.x=t.clientX,p.y=t.clientY;let e=n(t,p.x,p.y);return!1===e&&(t.stopPropagation(),t.preventDefault()),e},mouseup:t=>{p.x=t.clientX,p.y=t.clientY;let e=o(t,p.x,p.y);return!1===e&&(t.stopPropagation(),t.preventDefault()),e},mousemove:t=>{let e={x:t.clientX,y:t.clientY},i=r(t,e.x,e.y,e.x-p.x,e.y-p.y);return p.x=e.x,p.y=e.y,!1===i&&(t.stopPropagation(),t.preventDefault()),i},wheel:t=>{const e=y*(t.deltaY>0?1:-1)*m,i=l(t,t.clientX,t.clientY,e);return!1===i&&(t.stopPropagation(),t.preventDefault()),i}}}enableNativeGestures(){document.removeEventListener("gesturestart",a),document.removeEventListener("gesturechange",a),document.removeEventListener("gestureend",a)}disableNativeGestures(){document.addEventListener("gesturestart",a),document.addEventListener("gesturechange",a),document.addEventListener("gestureend",a)}enableTouchGestures(){this.listenerElement.addEventListener("touchstart",this.listeners.touchstart),document.addEventListener("touchend",this.listeners.touchend),document.addEventListener("touchmove",this.listeners.touchmove)}disableTouchGestures(){this.listenerElement.removeEventListener("touchstart",this.listeners.touchstart),document.removeEventListener("touchend",this.listeners.touchend),document.removeEventListener("touchmove",this.listeners.touchmove)}enableMouseGestures(){this.listenerElement.addEventListener("mousedown",this.listeners.mousedown),document.addEventListener("mouseup",this.listeners.mouseup),document.addEventListener("mousemove",this.listeners.mousemove),this.listenerElement.addEventListener("wheel",this.listeners.wheel),document.addEventListener("mouseleave",this.listeners.mouseup)}disableMouseGestures(){this.listenerElement.removeEventListener("mousedown",this.listeners.mousedown),document.removeEventListener("mouseup",this.listeners.mouseup),document.removeEventListener("mousemove",this.listeners.mousemove),document.removeEventListener("wheel",this.listeners.wheel),document.removeEventListener("mouseleave",this.listeners.mouseup)}}x.EVT_NAME_POINTERDOWN=c,x.EVT_NAME_POINTERMOVE=f,x.EVT_NAME_POINTERUP=u,x.EVT_NAME_POINTERZOOM=h;const p=x;function g(t,e){const i={...t,...e};return Object.entries(e).forEach((({0:e,1:s})=>{e in t&&"object"==typeof s&&!(t=>t instanceof Array)(s)&&null!==s&&(i[e]=g(t[e],s))})),i}const m={focus:{points:{innerRadius:t=>2*t.options.lineWidth,outerRadius:t=>2*t.options.lineWidth+t.options.lineWidth},axes:{x:{color:"rgba(0,0,0,0.1)",lineWidth:1},y:{color:"rgba(0,0,0,0.1)",lineWidth:1}}},color:{border:"rgba(0,0,0,0)",background:"#000000",text:"#ffffff"},shadow:{offsetX:0,offsetY:15,blur:5,color:"rgba(0,0,0,0.2)"},borderRadius:{leftTop:5,rightTop:5,leftBottom:5,rightBottom:5},viewportPadding:{left:15,right:15,top:15,bottom:15},padding:{left:25,right:10,top:5,bottom:5},mark:{offsetLeft:15,offsetTop:15,innerRadius:0,outerRadius:3}};function y(t,e){return t.bottom>e.top&&t.right>e.left&&t.top<e.bottom&&t.left<e.right}function b(t){const e=t.length;for(let i=0;i<e;i++)for(let s=0;s<e;s++)if(i!==s&&y(t[i].boundingRect,t[s].boundingRect))return!0;return!1}const v={xCanvasStep:25,yCanvasStep:25,xAxisStep:1,yAxisStep:1,xOffset:0,yOffset:0,xScale:1,yScale:1,xAxisSubdivisions:10,yAxisSubdivisions:10,lineWidth:1,pointSize:0,fontSize:15,fontFamily:"monospace",xAxisLabelXOffset:0,xAxisLabelYOffset:0,xAxisLabelDynamicPosition:!0,xAxisLabelSpacing:15,xAxisLabelFormat:t=>t.toFixed(4),xAxisLabelJoiningStep:5,xAxisLabelMarkOffset:-2,xAxisLabelMarkSize:4,xAxisLabelDisplayZero:!0,xAxisLabelEnable:!0,yAxisLabelXOffset:0,yAxisLabelYOffset:0,yAxisLabelDynamicPosition:!0,yAxisLabelSpacing:0,yAxisLabelFormat:t=>t.toFixed(4),yAxisLabelJoiningStep:5,yAxisLabelMarkOffset:-2,yAxisLabelMarkSize:4,yAxisLabelDisplayZero:!0,yAxisLabelEnable:!0,backgroundColor:"#ffffff",gridColor:"rgba(0,0,0,0.1)",axesColor:"rgba(0,0,0,0.5)",userTranslateX:!0,userTranslateY:!0,userScaleX:!0,userScaleY:!0,canvasRatio:1,canvasPixelRatio:1,clearFrame:!1,hints:{settings:{focus:{points:{innerRadius:t=>2*t.options.lineWidth,outerRadius:t=>2*t.options.lineWidth+t.options.lineWidth},axes:{x:{color:"rgba(0,0,0,0.1)",lineWidth:1},y:{color:"rgba(0,0,0,0.1)",lineWidth:1}}},color:{border:"rgba(0,0,0,0)",background:"#000000",text:"#ffffff"},shadow:{offsetX:0,offsetY:15,blur:5,color:"rgba(0,0,0,0.2)"},borderRadius:{leftTop:5,rightTop:5,leftBottom:5,rightBottom:5},viewportPadding:{left:15,right:15,top:15,bottom:15},padding:{left:25,right:10,top:5,bottom:5},mark:{offsetLeft:15,offsetTop:15,innerRadius:0,outerRadius:3}},hintText:(t,e,i,s)=>`X: ${s.xAxisLabelFormat(t)}\nY: ${s.yAxisLabelFormat(e)}`,createHints:function(t,e,i,n,o){const{hintText:l,settings:r}=n.hints,a=g(m,r),{focus:c,borderRadius:f,padding:u,mark:h}=a,{innerRadius:d,outerRadius:x}=c.points,p=s(),{transform:y,measureText:b}=o,v=[];for(let t=0,e=i.length;t<e;t++){const e=i[t],s=e.focusPoint;if(s){y(p,s);const t=l(s[0],s[1],e,n).split("\n");let i=0,o=0,r=0;for(let e=0,s=t.length;e<s;e++){const s=b(t[e]),l=s.width;i<l&&(i=l),o+=n.fontSize;const a=-Math.abs(s.actualBoundingBoxAscent),c=Math.abs(s.actualBoundingBoxDescent);r=n.fontSize-(c-a)}o+=u.top+u.bottom+r,i+=u.left+u.right;const a=p[0]+20,c=p[1]-o/2;v.push({focusPoints:[{x:p[0],y:p[1],innerRadius:d(e),outerRadius:x(e),dataset:e}],left:a,top:c,right:a+i,bottom:c+o,correction:r,texts:[{offsetLeft:u.left,offsetTop:u.top,contents:t}],padding:u,marks:[{...h,dataset:e}]})}}return y(p,t),{focus:{origin:t,x:p[0],y:p[1]},viewport:{...e,backgroundColor:n.backgroundColor},settings:g(a,{font:{family:n.fontFamily,size:n.fontSize},borderRadius:f?[f.leftTop,f.rightTop,f.rightBottom,f.leftBottom]:null}),helpers:o,list:v}},displaceHints:t=>{const{list:e,settings:i,viewport:{width:s,height:n},helpers:{isIntersects:o}}=t,l=i.viewportPadding,r=l.left,a=s-l.left-l.right,c=l.top,f=n-l.top-l.bottom;let u=[...e].sort(((t,e)=>t.focusPoints[t.focusPoints.length-1].y-e.focusPoints[0].y));for(let t=0;t<2;t++){for(let t=0,e=u.length;t<e;t++){const i=u[t];if(null!==i){for(let s=t+1;s<e;s++){const t=u[s];if(null!==t&&o(i,t)){const e=i.bottom-i.top-i.padding.bottom-t.padding.top-t.padding.bottom;for(let i=0,s=t.texts.length;i<s;i++)t.texts[i].offsetTop+=e;for(let i=0,s=t.marks.length;i<s;i++)t.marks[i].offsetTop+=e;i.right=Math.max(i.right,i.left+(t.right-t.left)),i.bottom+=t.bottom-t.top-i.padding.bottom-t.padding.top-i.correction,i.texts=i.texts.concat(t.texts),i.focusPoints=i.focusPoints.concat(t.focusPoints),i.marks=i.marks.concat(t.marks),u[s]=null}}u[t]=i}}u=u.filter((t=>t));for(let t=0,e=u.length;t<e;t++){const e=u[t];if(e.left<r){const t=r-e.left;e.left+=t,e.right+=t}else if(e.right>a){const t=e.right-a;e.left-=t,e.right-=t}if(e.top<c){const t=c-e.top;e.top+=t,e.bottom+=t}else if(e.bottom>f){const t=e.bottom-f;e.top-=t,e.bottom-=t}}}return{...t,list:u}},renderHints:(t,e)=>{const{list:i,settings:{font:s,color:n,shadow:o,borderRadius:l,focus:{axes:r}},viewport:{width:a,height:c,pixelRatio:f,backgroundColor:u}}=e;if(r.y){const{color:e,lineWidth:s}=r.y;t.fillStyle=e;for(let e=0,n=i.length;e<n;e++){const{focusPoints:n}=i[e];for(let e=0,i=n.length;e<i;e++){const{y:i}=n[e];t.fillRect(0,i,a,s*f)}}}if(r.x){const{color:i,lineWidth:s}=r.x;t.fillStyle=i,t.fillRect(e.focus.x,0,s*f,c)}if(o){const{offsetX:e,offsetY:s,blur:n,color:r}=o;t.fillStyle="rgb(255,255,255)",t.shadowColor=r,t.shadowOffsetX=e,t.shadowOffsetY=s,t.shadowBlur=n;for(let e=0,s=i.length;e<s;e++){const{left:s,top:n,right:o,bottom:r}=i[e];l?(t.beginPath(),t.roundRect(s,n,o-s,r-n,l),t.fill()):t.fillRect(s,n,o-s,r-n)}t.shadowColor="transparent"}for(let e=0,s=i.length;e<s;e++){const{focusPoints:s}=i[e];for(let e=0,i=s.length;e<i;e++){const{x:i,y:n,innerRadius:o,outerRadius:l,dataset:{options:{lineColor:r}}}=s[e];t.fillStyle=r.toString(),t.beginPath(),t.arc(i,n,l*f,0,2*Math.PI,!1),t.fill(),t.fillStyle=u,t.beginPath(),t.arc(i,n,o*f,0,2*Math.PI,!1),t.fill()}}const{border:h,background:d,text:x}=n,p=s.size*f;t.font=`${p}px/1 ${s.family}`;for(let e=0,n=i.length;e<n;e++){let{left:n,top:o,right:r,bottom:a,texts:c,marks:p}=i[e];t.strokeStyle=h,t.fillStyle=d,l?(t.beginPath(),t.roundRect(n,o,r-n,a-o,l),t.fill(),t.stroke()):t.fillRect(n,o,r-n,a-o),t.fillStyle=x;for(let e=0,i=c.length;e<i;e++){let{offsetLeft:i,offsetTop:l,contents:r}=c[e];i+=n,l+=o;for(let e=0,n=r.length;e<n;e++)t.fillText(r[e],i,l+s.size),l+=s.size}for(let e=0,i=p.length;e<i;e++){const{offsetLeft:i,offsetTop:s,innerRadius:l,outerRadius:r,dataset:{options:{lineColor:a}}}=p[e],c=i+n,h=s+o;t.fillStyle=a.toString(),t.beginPath(),t.arc(c,h,r*f,0,2*Math.PI,!1),t.fill(),t.fillStyle=u,t.beginPath(),t.arc(c,h,l*f,0,2*Math.PI,!1),t.fill()}}}},cursorPointer:"pointer",cursorGrabbing:"grabbing",bindEventHandlers:!0,invertMouseWheel:!1,mouseWheelStep:.1},S=class{constructor(t,e={}){this.options=e=g(v,e),this.elCanvas=t,this.ctx=t.getContext("2d"),this.scale=s(e.xScale,e.yScale),this.translate=s(e.xOffset,e.yOffset),this.focusPoint=s(0,0),this.datasets=[],t.style.cursor=e.cursorPointer;const i={down:!1,pt0:s(0,0),pt:s(0,0),delta:s(0,0)},r=(i,s)=>{const{clientX:n,clientY:o}=s,{left:l,right:r,top:a,bottom:c}=t.getBoundingClientRect();return i[0]=(n-l)/e.canvasRatio,i[1]=(o-a)/e.canvasRatio,l<=n&&n<=r&&a<=o&&o<=c};this.isListening=!1,this.listeners={},this.listeners[p.EVT_NAME_POINTERDOWN]=s=>{t.style.cursor=e.cursorGrabbing,s.detail.originalEvent.preventDefault(),i.down=!0,r(i.pt0,s.detail)},this.listeners[p.EVT_NAME_POINTERUP]=s=>{i.down=!1,t.style.cursor=e.cursorPointer},this.listeners[p.EVT_NAME_POINTERMOVE]=t=>{const a=r(i.pt,t.detail);if(i.down){c=i.delta,f=i.pt,u=i.pt0,c[0]=f[0]-u[0],c[1]=f[1]-u[1],n(i.pt0,i.pt);const t=s(e.userTranslateX?i.delta[0]:0,e.userTranslateY?i.delta[1]:0);this.move(t),this.repaint()}else if(a){const t=s();!function(t,e,i,s){t[0]=(e[0]-s[0])/i[0],t[1]=(e[1]-s[1])/i[1]}(t,i.pt,s(e.xCanvasStep,e.yCanvasStep),this.translate),t[1]=-t[1],o(t,t,s(e.xAxisStep,e.yAxisStep)),l(t,t,this.scale),this.computeFocusPoints(t),this.repaint()}var c,f,u},this.listeners[p.EVT_NAME_POINTERZOOM]=t=>{t.detail.originalEvent.preventDefault();const n=t.detail.deltaScale,o=s(e.userScaleX?n:0,e.userScaleY?n:0);r(i.pt,t.detail),this.zoomAroundPoint(o,i.pt),this.repaint()},this.touchGestures=new p(t,{invertMouseWheel:e.invertMouseWheel,mouseWheelStep:e.mouseWheelStep}),e.bindEventHandlers&&this.bind()}computeFocusPoints(t){this.datasets.forEach((e=>{const i=e.points,n=((t,e,s,n)=>{let o=-1;for(;e<=s;){let t=e+Math.floor((s-e+1)/2),l=i[t][0];l<n?(o=t,e=t+1):(l>n||l===n)&&(s=t-1)}return o})(0,0,i.length-1,t[0]),o=n+1;if(n>=0&&o<i.length){const l=s(),r=i[n],a=i[o],c=(t[0]-r[0])/(a[0]-r[0]);!function(t,e,i,s){t[0]=e[0]+s[0]*(i[0]-e[0]),t[1]=e[1]+s[1]*(i[1]-e[1])}(l,r,a,s(c,e.options.isStepped?0:c)),e.focusPoint=l}else e.focusPoint=null})),n(this.focusPoint,t)}bind(){if(!this.isListening){for(let t in this.listeners)this.elCanvas.addEventListener(t,this.listeners[t]);this.touchGestures.enableTouchGestures(),this.touchGestures.enableMouseGestures(),this.isListening=!0}}unbind(){if(this.isListening){for(let t in this.listeners)this.elCanvas.removeEventListener(t,this.listeners[t]);this.touchGestures.disableTouchGestures(),this.touchGestures.disableMouseGestures(),this.isListening=!1}}fitView(t,e=!0){let i=this.elCanvas.width,n=this.elCanvas.height;if(i<=0||n<=0||Math.abs(t.width)<=0||Math.abs(t.height)<=0)return!1;const o=new DOMRect(t.x,-t.y-t.height,t.width,t.height),l=this.options,r=l.canvasRatio*l.canvasPixelRatio,a=s(l.xCanvasStep,l.yCanvasStep),c=s(l.xAxisStep,l.yAxisStep);if(i=i/r/a[0]*c[0],n=n/r/a[1]*c[1],this.scale[0]=i/o.width,this.scale[1]=n/o.height,e&&(this.scale[1]>this.scale[0]?this.scale[1]=this.scale[0]:this.scale[0]=this.scale[1]),this.translate[0]=-o.x/c[0]*a[0]*this.scale[0],this.translate[1]=-o.y/c[1]*a[1]*this.scale[1],e){const t=(i/this.scale[0]-o.width)/2,e=(n/this.scale[1]-o.height)/2;this.translate[0]+=t*a[0]*this.scale[0]/c[0],this.translate[1]+=e*a[1]*this.scale[1]/c[1]}return!0}fitViewAuto(t=!0){this.fitView(this.getBoundingRect(null,0,null,0),t),this.repaint()}getBoundingRect(t=null,e=null,i=null,s=null){let n=t,o=i,l=e,r=s;for(let t=0,e=this.datasets.length;t<e;t++)for(let e=0,i=this.datasets[t].points,s=i.length;e<s;e++){const[t,s]=i[e];(null===n||n>t)&&(n=t),(null===o||o<t)&&(o=t),(null===l||l>s)&&(l=s),(null===r||r<s)&&(r=s)}const a=new DOMRect(n,l,o-n,r-l);return a.minX=n,a.minY=l,a.maxX=o,a.maxY=r,a}move(t){var e,i,s;e=this.translate,i=this.translate,s=t,e[0]=i[0]+s[0],e[1]=i[1]+s[1]}zoomAroundPoint(t,e){const i=this.translate,s=this.scale;!function(t,e,i,s){t[0]=e[0]-s[0]*(i[0]-e[0]),t[1]=e[1]-s[1]*(i[1]-e[1])}(i,i,e,t),r(s,s,t,s)}repaint(){let t,e;const n=this.options,a=this.ctx,c=this.elCanvas.width,f=this.elCanvas.height,u=this.scale,h=this.datasets;if(c<=0||f<=0||0===u[0]||0===u[1])return;const d=n.canvasRatio*n.canvasPixelRatio,x=s(n.xCanvasStep*d,n.yCanvasStep*d),p=s(this.translate[0]*d,this.translate[1]*d),g=s(x[0]*u[0],x[1]*u[1]),m=s(n.xAxisStep,n.yAxisStep),v=s(1,1),S=s(n.xAxisSubdivisions,n.yAxisSubdivisions);for(;g[0]>x[0]*S[0];)g[0]/=S[0],v[0]/=S[0];for(;g[1]>x[1]*S[1];)g[1]/=S[1],v[1]/=S[1];for(;g[0]<x[0];)g[0]*=S[0],v[0]*=S[0];for(;g[1]<x[1];)g[1]*=S[1],v[1]*=S[1];const L=p[0]-(Math.floor(p[0]/g[0])+(p[0]>0?1:0))*g[0],E=p[1]-(Math.floor(p[1]/g[1])+(p[1]>0?1:0))*g[1],A=(t,e)=>{o(t,e,x),l(t,t,m),t[1]=-t[1],r(t,t,u,p)},R=s();n.clearFrame&&a.clearRect(0,0,c,f),a.fillStyle=n.backgroundColor,a.fillRect(0,0,c,f),a.fillStyle=n.gridColor;for(let t=L;t<=c;t+=g[0])a.fillRect(t,0,1*d,f);for(let t=E;t<=f;t+=g[1])a.fillRect(0,t,c,1*d);a.fillStyle=n.axesColor,a.fillRect(p[0],0,1*d,f),a.fillRect(0,p[1],c,1*d);for(let t=0,i=h.length;t<i;t++){const i=h[t],s=i.points,n=s.length;if(n>1){if(a.strokeStyle=i.options.lineColor,a.lineWidth=i.options.lineWidth*d,a.beginPath(),A(R,s[0]),a.moveTo(R[0],R[1]),i.options.isStepped){e=R[1];for(let t=1;t<n;t++)A(R,s[t]),a.lineTo(R[0],e),a.lineTo(R[0],R[1]),e=R[1]}else for(let t=1;t<n;t++)A(R,s[t]),a.lineTo(R[0],R[1]);if(a.stroke(),i.options.pointRadius>0){a.fillStyle=i.options.lineColor;const t=i.options.pointRadius,e=2*Math.PI;A(R,s[0]),a.beginPath(),a.arc(R[0],R[1],t,0,e,!1),a.fill();for(let i=1;i<n;i++)A(R,s[i]),a.beginPath(),a.arc(R[0],R[1],t,0,e,!1),a.fill()}}}if(n.xAxisLabelEnable||n.yAxisLabelEnable){const s=n.fontSize*d;if(a.font=`${s}px/1 ${n.fontFamily}`,a.fillStyle=n.axesColor,n.xAxisLabelEnable){const t=n.xAxisLabelXOffset*d,o=n.xAxisLabelYOffset*d,l=n.xAxisLabelMarkOffset*d,r=n.xAxisLabelMarkSize*d,u=n.xAxisLabelSpacing*d,h=u/2;let x=[],y=!1,S=!1;for(let e=L;e<=c;e+=g[0]){const i=e-p[0],l=Math.round(i/g[0]),r=l*v[0]*m[0],c=n.xAxisLabelFormat(r),u=a.measureText(c),h={i:l,gridX:e,text:c,textMetrics:u,x:e-u.width/2+t,y:p[1]+s+o};x.push(h),h.y-s-o<0&&(y=!0),h.y+o>f&&(S=!0)}for(let t=0,i=x.length;t<i;t++){const i=x[t];e=i.y,n.xAxisLabelDynamicPosition&&(e=y?s+o:S?f-o:e);const l=new DOMRect(i.x-h,e-s,i.textMetrics.width+u,s);i.y=e,i.boundingRect=l}let E=n.xAxisLabelJoiningStep,A=x;for(;b(x);)x=A.filter((t=>i(Math.abs(t.i)%E))),E+=n.xAxisLabelJoiningStep;for(let t=0,e=x.length;t<e;t++){const e=x[t];(n.xAxisLabelDisplayZero||0!==e.i)&&(a.fillRect(e.gridX,p[1]+l,d,r),a.fillText(e.text,e.x,e.y))}}if(n.yAxisLabelEnable){const e=n.yAxisLabelXOffset*d,o=n.yAxisLabelYOffset*d,l=n.yAxisLabelMarkOffset*d,r=n.yAxisLabelMarkSize*d,u=n.yAxisLabelSpacing*d,h=u/2;let x=[],y=0,S=!1,L=!1;for(let t=E;t<=f;t+=g[1]){const i=p[1]-t,l=Math.round(i/g[1]),r=l*v[1]*m[1],f=n.yAxisLabelFormat(r),u=a.measureText(f),h={i:l,gridY:t,text:f,textMetrics:u,x:p[0]-u.width+e,y:t+s/2+o};x.push(h),y<u.width&&(y=u.width),h.x+e<0&&(S=!0),h.x+h.textMetrics.width-e>c&&(L=!0)}for(let i=0,o=x.length;i<o;i++){const o=x[i];t=o.x,n.yAxisLabelDynamicPosition&&(t=S?y-o.textMetrics.width-e:L?c-o.textMetrics.width+e:t);const l=new DOMRect(t,o.y-s-h,o.textMetrics.width,s+u);o.x=t,o.boundingRect=l}let A=n.yAxisLabelJoiningStep,R=x;for(;b(x);)x=R.filter((t=>i(Math.abs(t.i)%A))),A+=n.yAxisLabelJoiningStep;x=x.filter((t=>t.boundingRect.bottom>0&&t.boundingRect.top<f)),y=0,S=!1,L=!1;for(let t=0,i=x.length;t<i;t++){const i=x[t];i.x=p[0]-i.textMetrics.width+e,y<i.textMetrics.width&&(y=i.textMetrics.width),i.x+e<0&&(S=!0),i.x+i.textMetrics.width-e>c&&(L=!0)}for(let i=0,s=x.length;i<s;i++){const s=x[i];t=s.x,n.yAxisLabelDynamicPosition&&(t=S?y-s.textMetrics.width-e:L?c-s.textMetrics.width+e:t),s.x=t}for(let t=0,e=x.length;t<e;t++){const e=x[t];(n.yAxisLabelDisplayZero||0!==e.i)&&(a.fillRect(p[0]+l,e.gridY,r,d),a.fillText(e.text,e.x,e.y))}}}if(n.hints){const{createHints:t,displaceHints:e,renderHints:i}=n.hints;let s=t(this.focusPoint,{width:c,height:f,pixelRatio:d},h,n,{transform:A,isIntersects:y,measureText:t=>a.measureText(t)});s=e(s),i(a,s)}}},L=class{constructor(t={}){if(!("lineColor"in t)){const e=()=>Math.round(256*Math.random());t.lineColor=`rgb(${e()},${e()},${e()})`}"isStepped"in t||(t.isStepped=!1),"lineWidth"in t||(t.lineWidth=1),"pointRadius"in t||(t.pointRadius=0),this.options=t,this.points=[]}getBoundingRect(){let t=null,e=null,i=null,s=null;for(let n=0,o=this.points,l=o.length;n<l;n++){const[l,r]=o[n];(null===t||t>l)&&(t=l),(null===e||e<l)&&(e=l),(null===i||i>r)&&(i=r),(null===s||s<r)&&(s=r)}const n=new DOMRect(t,i,e-t,s-i);return n.minX=t,n.minY=i,n.maxX=e,n.maxY=s,n}};return e})()));